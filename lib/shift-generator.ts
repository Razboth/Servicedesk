/**
 * Shift Generation Algorithm
 *
 * Generates monthly shift schedules following complex rotation rules:
 * - Weekday night shifts: 1 staff per night
 * - Weekend shifts split into 4 types:
 *   * SATURDAY_DAY: 2 staff
 *   * SATURDAY_NIGHT: 1 staff
 *   * SUNDAY_DAY: 2 staff
 *   * SUNDAY_NIGHT: 1 staff (gets Monday off)
 * - Sunday night shift = Monday off (mandatory)
 * - Night shifts require off-day after
 * - Sabbath restrictions (no Friday night/Saturday for specific staff)
 * - Server access requirements with on-call backup
 * - Fair rotation distribution
 * - Minimum 3-day gap between night shifts
 * - Target 5 night shifts per person per month
 * - Leave requests are respected (staff on leave cannot be assigned)
 */

import { PrismaClient, ShiftType, StaffShiftType } from '@prisma/client';

interface StaffMember {
  id: string;
  userId: string;
  canWorkNightShift: boolean;
  canWorkWeekendDay: boolean;
  hasServerAccess: boolean;
  hasSabbathRestriction: boolean;
  preferredShiftType: StaffShiftType | null;
  maxNightShiftsPerMonth: number;
  minDaysBetweenNightShifts: number;
}

interface ShiftAssignmentData {
  staffProfileId: string;
  date: Date;
  shiftType: ShiftType;
  isAutoGenerated: boolean;
}

interface OnCallAssignmentData {
  staffProfileId: string;
  date: Date;
  reason: string;
}

interface GenerationStats {
  [staffId: string]: {
    nightCount: number;
    weekendDayCount: number;
    offCount: number;
    onCallCount: number;
    lastNightShift: number; // Day of month
  };
}

interface WeekendRotation {
  saturdayDay: string[];
  sundayDay: string[];
  saturdayNight: string[];
  sundayNight: string[];
}

export class ShiftGenerator {
  private prisma: PrismaClient;
  private staff: StaffMember[] = [];
  private stats: GenerationStats = {};
  private assignments: ShiftAssignmentData[] = [];
  private onCallAssignments: OnCallAssignmentData[] = [];
  private leaveRequests: Map<string, Date[]> = new Map(); // staffId -> array of leave dates
  private month: number;
  private year: number;
  private daysInMonth: number;
  private weekends: number[] = [];
  private fridays: number[] = [];
  private saturdays: number[] = [];

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.month = 0;
    this.year = 0;
    this.daysInMonth = 0;
  }

  /**
   * Generate complete shift schedule for a month
   */
  async generateSchedule(
    branchId: string,
    month: number,
    year: number,
    holidays: Date[] = []
  ): Promise<{
    assignments: ShiftAssignmentData[];
    onCallAssignments: OnCallAssignmentData[];
    stats: GenerationStats;
  }> {
    this.month = month;
    this.year = year;
    this.daysInMonth = new Date(year, month, 0).getDate();

    // Calculate weekends and special days
    this.calculateSpecialDays();

    // Load active staff members for the branch
    await this.loadStaffMembers(branchId);

    if (this.staff.length === 0) {
      throw new Error('No active staff members found for this branch');
    }

    // Load approved leave requests for this month
    await this.loadLeaveRequests(branchId);

    // Initialize statistics
    this.initializeStats();

    // Step 1: Mark holidays
    this.markHolidays(holidays);

    // Step 2: Assign weekend shifts
    this.assignWeekendShifts();

    // Step 3: Distribute weekday night shifts
    this.distributeWeekdayNightShifts();

    // Step 4: Generate on-call backup assignments
    this.generateOnCallBackup();

    return {
      assignments: this.assignments,
      onCallAssignments: this.onCallAssignments,
      stats: this.stats,
    };
  }

  /**
   * Load staff members eligible for shifts
   */
  private async loadStaffMembers(branchId: string): Promise<void> {
    const profiles = await this.prisma.staffShiftProfile.findMany({
      where: {
        branchId,
        isActive: true,
        OR: [
          { canWorkNightShift: true },
          { canWorkWeekendDay: true },
        ],
      },
      include: {
        user: true,
      },
    });

    this.staff = profiles.map((p) => ({
      id: p.id,
      userId: p.userId,
      canWorkNightShift: p.canWorkNightShift,
      canWorkWeekendDay: p.canWorkWeekendDay,
      hasServerAccess: p.hasServerAccess,
      hasSabbathRestriction: p.hasSabbathRestriction,
      preferredShiftType: p.preferredShiftType,
      maxNightShiftsPerMonth: p.maxNightShiftsPerMonth,
      minDaysBetweenNightShifts: p.minDaysBetweenNightShifts,
    }));
  }

  /**
   * Load approved leave requests for this month
   */
  private async loadLeaveRequests(branchId: string): Promise<void> {
    const monthStart = new Date(this.year, this.month - 1, 1);
    const monthEnd = new Date(this.year, this.month, 0);

    const leaveRequests = await this.prisma.leaveRequest.findMany({
      where: {
        staffProfile: {
          branchId,
        },
        status: 'APPROVED',
        OR: [
          {
            AND: [
              { startDate: { lte: monthEnd } },
              { endDate: { gte: monthStart } },
            ],
          },
        ],
      },
      include: {
        staffProfile: true,
      },
    });

    // Map staff IDs to their leave dates
    this.leaveRequests.clear();
    for (const leave of leaveRequests) {
      const leaveDates: Date[] = [];
      const currentDate = new Date(Math.max(leave.startDate.getTime(), monthStart.getTime()));
      const endDate = new Date(Math.min(leave.endDate.getTime(), monthEnd.getTime()));

      while (currentDate <= endDate) {
        leaveDates.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
      }

      const existingLeaves = this.leaveRequests.get(leave.staffProfileId) || [];
      this.leaveRequests.set(leave.staffProfileId, [...existingLeaves, ...leaveDates]);
    }
  }

  /**
   * Check if staff is on leave on a specific day
   */
  private isOnLeave(staffId: string, day: number): boolean {
    const leaveDates = this.leaveRequests.get(staffId);
    if (!leaveDates) return false;

    const checkDate = new Date(this.year, this.month - 1, day);
    return leaveDates.some(
      (leaveDate) =>
        leaveDate.getDate() === day &&
        leaveDate.getMonth() === this.month - 1 &&
        leaveDate.getFullYear() === this.year
    );
  }

  /**
   * Calculate special days in the month
   */
  private calculateSpecialDays(): void {
    this.weekends = [];
    this.fridays = [];
    this.saturdays = [];

    for (let day = 1; day <= this.daysInMonth; day++) {
      const date = new Date(this.year, this.month - 1, day);
      const dayOfWeek = date.getDay();

      if (dayOfWeek === 5) {
        // Friday
        this.fridays.push(day);
      } else if (dayOfWeek === 6) {
        // Saturday
        this.saturdays.push(day);
        this.weekends.push(day);
      } else if (dayOfWeek === 0) {
        // Sunday
        this.weekends.push(day);
      }
    }
  }

  /**
   * Initialize statistics tracking for all staff
   */
  private initializeStats(): void {
    this.stats = {};
    for (const staff of this.staff) {
      this.stats[staff.id] = {
        nightCount: 0,
        weekendDayCount: 0,
        offCount: 0,
        onCallCount: 0,
        lastNightShift: -10, // Initialize to allow immediate assignment
      };
    }
  }

  /**
   * Mark holidays in the schedule
   */
  private markHolidays(holidays: Date[]): void {
    for (const holiday of holidays) {
      const day = holiday.getDate();
      if (
        holiday.getMonth() + 1 === this.month &&
        holiday.getFullYear() === this.year
      ) {
        // Mark as holiday for all staff
        for (const staff of this.staff) {
          this.addAssignment(staff.id, day, ShiftType.HOLIDAY);
        }
      }
    }
  }

  /**
   * Assign weekend shifts following rotation rules
   * Pattern from HTML: Fixed rotation for day staff, balanced selection for night staff
   */
  private assignWeekendShifts(): void {
    const weekendDayStaff = this.staff.filter((s) => s.canWorkWeekendDay);
    const nightStaff = this.staff.filter((s) => s.canWorkNightShift);
    const nightStaffNoSabbath = nightStaff.filter((s) => !s.hasSabbathRestriction);

    if (weekendDayStaff.length < 2) {
      console.warn('Not enough weekend day staff (need at least 2)');
    }

    // Group weekends as Saturday-Sunday pairs
    const weekendPairs: [number, number][] = [];
    for (let i = 0; i < this.saturdays.length; i++) {
      const saturday = this.saturdays[i];
      const sunday = saturday + 1;
      if (sunday <= this.daysInMonth) {
        weekendPairs.push([saturday, sunday]);
      }
    }

    // Process each weekend
    weekendPairs.forEach((weekend, weekendIndex) => {
      const [saturday, sunday] = weekend;

      if (this.isHoliday(saturday) || this.isHoliday(sunday)) return;

      // === WEEKEND DAY SHIFTS ===
      // Pattern: Rotate through weekend day staff pool, 2 different staff each day
      const satDayAssigned: string[] = [];
      const sunDayAssigned: string[] = [];

      // Saturday day shift - assign 2 staff
      for (let slot = 0; slot < 2; slot++) {
        // Find least assigned weekend day staff who is available
        const available = weekendDayStaff
          .filter(s =>
            !this.isAssigned(s.id, saturday) &&
            !this.isOnLeave(s.id, saturday) &&
            !satDayAssigned.includes(s.id)
          )
          .sort((a, b) => this.stats[a.id].weekendDayCount - this.stats[b.id].weekendDayCount);

        if (available.length > 0) {
          const staff = available[0];
          this.addAssignment(staff.id, saturday, ShiftType.SATURDAY_DAY);
          this.stats[staff.id].weekendDayCount++;
          satDayAssigned.push(staff.id);

          // Add off day after - but only if they don't work Sunday
          if (sunday <= this.daysInMonth && !this.isAssigned(staff.id, sunday)) {
            this.addAssignment(staff.id, sunday, ShiftType.OFF);
            this.stats[staff.id].offCount++;
          }
        }
      }

      // Sunday day shift - assign 2 staff (prefer different from Saturday)
      for (let slot = 0; slot < 2; slot++) {
        // Prefer staff who didn't work Saturday
        const available = weekendDayStaff
          .filter(s =>
            !this.isAssigned(s.id, sunday) &&
            !this.isOnLeave(s.id, sunday) &&
            !sunDayAssigned.includes(s.id)
          )
          .sort((a, b) => {
            // Prioritize those who didn't work Saturday
            const aWorkedSat = satDayAssigned.includes(a.id) ? 1 : 0;
            const bWorkedSat = satDayAssigned.includes(b.id) ? 1 : 0;
            if (aWorkedSat !== bWorkedSat) return aWorkedSat - bWorkedSat;
            // Then sort by weekend day count
            return this.stats[a.id].weekendDayCount - this.stats[b.id].weekendDayCount;
          });

        if (available.length > 0) {
          const staff = available[0];
          this.addAssignment(staff.id, sunday, ShiftType.SUNDAY_DAY);
          this.stats[staff.id].weekendDayCount++;
          sunDayAssigned.push(staff.id);

          // Add off day on Monday
          const monday = sunday + 1;
          if (monday <= this.daysInMonth && !this.isAssigned(staff.id, monday)) {
            this.addAssignment(staff.id, monday, ShiftType.OFF);
            this.stats[staff.id].offCount++;
          }
        }
      }

      // === WEEKEND NIGHT SHIFTS ===

      // Saturday night - 1 staff (NO Sabbath restriction!)
      const satNightAvailable = nightStaffNoSabbath
        .filter(s => this.canWorkNightShift(s.id, saturday))
        .sort((a, b) => {
          // Sort by night count to balance workload
          const countDiff = this.stats[a.id].nightCount - this.stats[b.id].nightCount;
          if (countDiff !== 0) return countDiff;
          // Then by last night shift (prefer more rest)
          return this.stats[a.id].lastNightShift - this.stats[b.id].lastNightShift;
        });

      if (satNightAvailable.length > 0) {
        const staff = satNightAvailable[0];
        this.addAssignment(staff.id, saturday, ShiftType.SATURDAY_NIGHT);
        this.stats[staff.id].nightCount++;
        this.stats[staff.id].lastNightShift = saturday;

        // Off day on Sunday
        if (sunday <= this.daysInMonth && !this.isAssigned(staff.id, sunday)) {
          this.addAssignment(staff.id, sunday, ShiftType.OFF);
          this.stats[staff.id].offCount++;
        }
      }

      // Sunday night - 1 staff (Sabbath staff CAN work Sunday)
      const sunNightAvailable = nightStaff
        .filter(s => this.canWorkNightShift(s.id, sunday))
        .sort((a, b) => {
          // Sort by night count to balance workload
          const countDiff = this.stats[a.id].nightCount - this.stats[b.id].nightCount;
          if (countDiff !== 0) return countDiff;
          // Then by last night shift (prefer more rest)
          return this.stats[a.id].lastNightShift - this.stats[b.id].lastNightShift;
        });

      if (sunNightAvailable.length > 0) {
        const staff = sunNightAvailable[0];
        this.addAssignment(staff.id, sunday, ShiftType.SUNDAY_NIGHT);
        this.stats[staff.id].nightCount++;
        this.stats[staff.id].lastNightShift = sunday;

        // Sunday night = Monday off (MANDATORY)
        const monday = sunday + 1;
        if (monday <= this.daysInMonth && !this.isAssigned(staff.id, monday)) {
          this.addAssignment(staff.id, monday, ShiftType.OFF);
          this.stats[staff.id].offCount++;
        }
      }
    });
  }

  /**
   * Distribute weekday night shifts fairly
   * Pattern from HTML: 1 staff per night, balanced distribution, minimum gap enforcement
   */
  private distributeWeekdayNightShifts(): void {
    const nightStaff = this.staff.filter((s) => s.canWorkNightShift);
    const targetNights = 5; // Target nights per month per staff

    for (let day = 1; day <= this.daysInMonth; day++) {
      // Skip weekends and holidays
      if (this.weekends.includes(day) || this.isHoliday(day)) continue;

      // Find eligible staff for this night shift
      let eligible = nightStaff.filter((staff) => {
        return this.canWorkNightShift(staff.id, day);
      });

      if (eligible.length === 0) {
        // If no one is eligible with all constraints, relax some constraints
        // (but keep leave and Sabbath restrictions)
        eligible = nightStaff.filter((staff) => {
          if (this.isAssigned(staff.id, day)) return false;
          if (this.isOnLeave(staff.id, day)) return false;

          // Check Sabbath restriction
          if (staff.hasSabbathRestriction) {
            if (this.fridays.includes(day) || this.saturdays.includes(day)) {
              return false;
            }
          }

          return true;
        });
      }

      if (eligible.length === 0) {
        console.warn(`No eligible night staff for day ${day}`);
        continue;
      }

      // Sort by multiple criteria (matching HTML pattern)
      eligible.sort((a, b) => {
        // 1. Prioritize those below target
        const aBelowTarget = this.stats[a.id].nightCount < targetNights ? 0 : 1;
        const bBelowTarget = this.stats[b.id].nightCount < targetNights ? 0 : 1;
        if (aBelowTarget !== bBelowTarget) return aBelowTarget - bBelowTarget;

        // 2. Balance night count (fewest nights first)
        const countDiff = this.stats[a.id].nightCount - this.stats[b.id].nightCount;
        if (countDiff !== 0) return countDiff;

        // 3. Prefer more rest (last night shift earlier)
        const restDiff = this.stats[a.id].lastNightShift - this.stats[b.id].lastNightShift;
        if (restDiff !== 0) return restDiff;

        // 4. On critical days (month start/mid/end), prefer server access
        if ([1, 15, this.daysInMonth].includes(day)) {
          if (a.hasServerAccess && !b.hasServerAccess) return -1;
          if (!a.hasServerAccess && b.hasServerAccess) return 1;
        }

        return 0;
      });

      const selected = eligible[0];

      // Assign night shift
      this.addAssignment(selected.id, day, ShiftType.NIGHT);
      this.stats[selected.id].nightCount++;
      this.stats[selected.id].lastNightShift = day;

      // Add mandatory off day after night shift (only on weekdays)
      const nextDay = day + 1;
      if (nextDay <= this.daysInMonth &&
          !this.weekends.includes(nextDay) &&
          !this.isHoliday(nextDay) &&
          !this.isAssigned(selected.id, nextDay)) {
        this.addAssignment(selected.id, nextDay, ShiftType.OFF);
        this.stats[selected.id].offCount++;
      }
    }
  }

  /**
   * Generate on-call backup for shifts without server access
   * Pattern from HTML: Rotate fairly among server access staff
   */
  private generateOnCallBackup(): void {
    const serverAccessStaff = this.staff.filter((s) => s.hasServerAccess);

    if (serverAccessStaff.length === 0) {
      console.warn('No server access staff available for on-call rotation');
      return;
    }

    for (let day = 1; day <= this.daysInMonth; day++) {
      // Find all shifts for this day
      const dayAssignments = this.assignments.filter((a) => {
        const date = new Date(this.year, this.month - 1, day);
        return a.date.getTime() === date.getTime();
      });

      // Check if any shift on this day needs on-call backup
      let needsOnCall = false;
      let reason = '';
      let shiftStaff: typeof this.staff[0] | null = null;

      for (const assignment of dayAssignments) {
        const staff = this.staff.find((s) => s.id === assignment.staffProfileId);
        if (!staff) continue;

        // Weekend day shifts ALWAYS need on-call (staff don't have server access)
        if (assignment.shiftType === ShiftType.WEEKEND_DAY && !staff.hasServerAccess) {
          needsOnCall = true;
          reason = 'Weekend day shift - no server access';
          shiftStaff = staff;
          break;
        }

        // Night shifts without server access need on-call
        if ((assignment.shiftType === ShiftType.NIGHT || assignment.shiftType === ShiftType.WEEKEND_NIGHT) &&
            !staff.hasServerAccess) {
          needsOnCall = true;
          reason = assignment.shiftType === ShiftType.WEEKEND_NIGHT
            ? 'Weekend night shift - no server access'
            : 'Weekday night shift - no server access';
          shiftStaff = staff;
          break;
        }
      }

      if (needsOnCall && shiftStaff) {
        // Find available on-call staff (not on shift, not off, not on leave, not Sabbath)
        const available = serverAccessStaff.filter((s) => {
          // Cannot be on any active shift
          const isOnShift = dayAssignments.some(
            (a) => a.staffProfileId === s.id &&
            [ShiftType.NIGHT, ShiftType.WEEKEND_NIGHT, ShiftType.WEEKEND_DAY].includes(a.shiftType)
          );
          if (isOnShift) return false;

          // Cannot be on off day
          const isOff = dayAssignments.some(
            (a) => a.staffProfileId === s.id && a.shiftType === ShiftType.OFF
          );
          if (isOff) return false;

          // Cannot be on leave
          if (this.isOnLeave(s.id, day)) return false;

          // Sabbath check
          if (s.hasSabbathRestriction) {
            if (this.fridays.includes(day) || this.saturdays.includes(day)) {
              return false;
            }
          }

          return true;
        });

        if (available.length > 0) {
          // Rotate fairly - pick the one with least on-call assignments
          available.sort((a, b) =>
            this.stats[a.id].onCallCount - this.stats[b.id].onCallCount
          );

          const onCall = available[0];

          this.onCallAssignments.push({
            staffProfileId: onCall.id,
            date: new Date(this.year, this.month - 1, day),
            reason,
          });

          this.stats[onCall.id].onCallCount++;
        } else {
          console.warn(`No available on-call staff for day ${day}`);
        }
      }
    }
  }

  /**
   * Check if staff can work night shift on given day
   */
  private canWorkNightShift(staffId: string, day: number): boolean {
    const staff = this.staff.find((s) => s.id === staffId);
    if (!staff) return false;

    // Check if already assigned
    if (this.isAssigned(staffId, day)) return false;

    // Check if on leave
    if (this.isOnLeave(staffId, day)) return false;

    // Check Sabbath restriction (Friday nights and Saturdays)
    if (staff.hasSabbathRestriction) {
      if (this.fridays.includes(day) || this.saturdays.includes(day)) {
        return false;
      }
    }

    // Check minimum gap between night shifts
    const daysSinceLastNight = day - this.stats[staffId].lastNightShift;
    if (daysSinceLastNight < staff.minDaysBetweenNightShifts) {
      return false;
    }

    // Check if below maximum night shifts per month
    if (this.stats[staffId].nightCount >= staff.maxNightShiftsPerMonth) {
      return false;
    }

    return true;
  }

  /**
   * Check if staff is already assigned on a day
   */
  private isAssigned(staffId: string, day: number): boolean {
    const date = new Date(this.year, this.month - 1, day);
    return this.assignments.some(
      (a) => a.staffProfileId === staffId && a.date.getTime() === date.getTime()
    );
  }

  /**
   * Check if a day is a holiday
   */
  private isHoliday(day: number): boolean {
    const date = new Date(this.year, this.month - 1, day);
    return this.assignments.some(
      (a) => a.date.getTime() === date.getTime() && a.shiftType === ShiftType.HOLIDAY
    );
  }

  /**
   * Add a shift assignment
   */
  private addAssignment(staffId: string, day: number, shiftType: ShiftType): void {
    const date = new Date(this.year, this.month - 1, day);
    this.assignments.push({
      staffProfileId: staffId,
      date,
      shiftType,
      isAutoGenerated: true,
    });
  }
}