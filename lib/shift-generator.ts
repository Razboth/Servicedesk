/**
 * Shift Generation Algorithm - New 5-Type Daily System
 *
 * Generates monthly shift schedules with 5 shift types:
 * 1. NIGHT_WEEKDAY (20:00-07:59) - Weekdays only - 1 staff - Auto OFF day H+1
 * 2. DAY_WEEKEND (08:00-19:00) - Weekends/Holidays only - 1 staff
 * 3. NIGHT_WEEKEND (20:00-07:59) - Weekends/Holidays only - 1 staff - Auto OFF day H+1
 * 4. STANDBY_ONCALL - Everyday - 1 staff
 * 5. STANDBY_BRANCH - Everyday - 1 staff
 *
 * Additional types: OFF, LEAVE, HOLIDAY
 *
 * Rules:
 * - Each shift type can only have 1 staff assigned per day
 * - NIGHT_WEEKDAY and NIGHT_WEEKEND get auto OFF day (H+1)
 * - Fair rotation distribution
 * - Sabbath restrictions respected
 * - Leave requests honored
 */

import { PrismaClient, ShiftType, StaffShiftType } from '@prisma/client';

interface StaffMember {
  id: string;
  userId: string;
  canWorkType1: boolean; // NIGHT_WEEKDAY
  canWorkType2: boolean; // DAY_WEEKEND
  canWorkType3: boolean; // NIGHT_WEEKEND
  canWorkType4: boolean; // STANDBY_ONCALL
  canWorkType5: boolean; // STANDBY_BRANCH
  hasServerAccess: boolean;
  hasSabbathRestriction: boolean;
  preferredShiftType: StaffShiftType | null;
  maxNightShiftsPerMonth: number;
  minDaysBetweenNightShifts: number;
}

interface ShiftAssignmentData {
  staffProfileId: string;
  date: Date;
  shiftType: ShiftType;
  isAutoGenerated: boolean;
}

interface GenerationStats {
  [staffId: string]: {
    nightWeekdayCount: number;
    dayWeekendCount: number;
    nightWeekendCount: number;
    standbyOnCallCount: number;
    standbyBranchCount: number;
    offCount: number;
    lastNightShift: number; // Day of month
  };
}

export class ShiftGenerator {
  private prisma: PrismaClient;
  private staff: StaffMember[] = [];
  private stats: GenerationStats = {};
  private assignments: ShiftAssignmentData[] = [];
  private leaveRequests: Map<string, Date[]> = new Map();
  private previousMonthLastAssignments: Map<string, { date: Date; shiftType: string }> = new Map();
  private month: number;
  private year: number;
  private daysInMonth: number;
  private weekends: number[] = [];
  private holidays: Set<number> = new Set();
  private daysNeedingServerStandby: Set<number> = new Set();

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.month = 0;
    this.year = 0;
    this.daysInMonth = 0;
  }

  /**
   * Generate complete shift schedule for a month
   */
  async generateSchedule(
    branchId: string,
    month: number,
    year: number,
    holidayDates: Date[] = [],
    scheduleId?: string
  ): Promise<{
    assignments: ShiftAssignmentData[];
    onCallAssignments: any[];
    stats: GenerationStats;
  }> {
    this.month = month;
    this.year = year;
    this.daysInMonth = new Date(year, month, 0).getDate();

    console.log(`\n=== Generating schedule for ${month}/${year} ===`);

    // Calculate weekends and holidays
    this.calculateWeekends();
    this.markHolidayDays(holidayDates);

    // Load active staff members
    await this.loadStaffMembers(branchId);

    if (this.staff.length === 0) {
      throw new Error('No active staff members found for this branch');
    }

    console.log(`Loaded ${this.staff.length} staff members`);

    // Load leave requests
    await this.loadLeaveRequests(branchId, scheduleId);

    // Load previous month assignments for continuity
    await this.loadPreviousMonthAssignments(branchId);

    // Initialize statistics
    this.initializeStats();

    // Step 1: Create HOLIDAY assignments
    this.createHolidayAssignments();

    // Step 2: Create LEAVE assignments
    this.createLeaveAssignments();

    // Step 3: Generate daily shifts
    for (let day = 1; day <= this.daysInMonth; day++) {
      this.generateDayShifts(day);
    }

    console.log('\n=== Generation Statistics ===');
    this.printStats();

    return {
      assignments: this.assignments,
      onCallAssignments: [], // No on-call assignments in new system
      stats: this.stats,
    };
  }

  /**
   * Load staff members eligible for shifts
   */
  private async loadStaffMembers(branchId: string): Promise<void> {
    const profiles = await this.prisma.staffShiftProfile.findMany({
      where: {
        branchId,
        isActive: true,
        OR: [
          { canWorkType1: true },
          { canWorkType2: true },
          { canWorkType3: true },
          { canWorkType4: true },
          { canWorkType5: true },
        ],
      },
      include: {
        user: true,
      },
    });

    this.staff = profiles.map((p) => ({
      id: p.id,
      userId: p.userId,
      canWorkType1: p.canWorkType1,
      canWorkType2: p.canWorkType2,
      canWorkType3: p.canWorkType3,
      canWorkType4: p.canWorkType4,
      canWorkType5: p.canWorkType5,
      hasServerAccess: p.hasServerAccess,
      hasSabbathRestriction: p.hasSabbathRestriction,
      preferredShiftType: p.preferredShiftType,
      maxNightShiftsPerMonth: p.maxNightShiftsPerMonth,
      minDaysBetweenNightShifts: p.minDaysBetweenNightShifts,
    }));
  }

  /**
   * Load approved leave requests for this month
   */
  private async loadLeaveRequests(branchId: string, scheduleId?: string): Promise<void> {
    const monthStart = new Date(this.year, this.month - 1, 1);
    const monthEnd = new Date(this.year, this.month, 0);

    const whereClause: any = {
      staffProfile: {
        branchId,
      },
      status: 'APPROVED',
      OR: [
        {
          AND: [
            { startDate: { lte: monthEnd } },
            { endDate: { gte: monthStart } },
          ],
        },
      ],
    };

    // If scheduleId is provided, also include leaves linked to this schedule
    if (scheduleId) {
      whereClause.OR.push({ scheduleId });
    }

    const leaveRequests = await this.prisma.leaveRequest.findMany({
      where: whereClause,
      include: {
        staffProfile: true,
      },
    });

    this.leaveRequests.clear();
    for (const leave of leaveRequests) {
      const leaveDates: Date[] = [];

      // Normalize dates to UTC midnight to avoid timezone issues
      const startDate = new Date(leave.startDate);
      startDate.setUTCHours(0, 0, 0, 0);

      const endDate = new Date(leave.endDate);
      endDate.setUTCHours(0, 0, 0, 0);

      const monthStartUTC = new Date(monthStart);
      monthStartUTC.setUTCHours(0, 0, 0, 0);

      const monthEndUTC = new Date(monthEnd);
      monthEndUTC.setUTCHours(23, 59, 59, 999);

      // Get the actual range within the month
      const currentDate = new Date(Math.max(startDate.getTime(), monthStartUTC.getTime()));
      const rangeEnd = new Date(Math.min(endDate.getTime(), monthEndUTC.getTime()));

      // Iterate through all days in the leave range
      while (currentDate <= rangeEnd) {
        leaveDates.push(new Date(currentDate));
        currentDate.setUTCDate(currentDate.getUTCDate() + 1);
      }

      const existingLeaves = this.leaveRequests.get(leave.staffProfileId) || [];
      this.leaveRequests.set(leave.staffProfileId, [...existingLeaves, ...leaveDates]);

      console.log(`Added ${leaveDates.length} leave days for staff ${leave.staffProfileId}`);
    }

    console.log(`Loaded leave requests for ${this.leaveRequests.size} staff members`);
  }

  /**
   * Load previous month's last assignments for continuity
   */
  private async loadPreviousMonthAssignments(branchId: string): Promise<void> {
    const prevMonth = this.month === 1 ? 12 : this.month - 1;
    const prevYear = this.month === 1 ? this.year - 1 : this.year;
    const prevMonthDays = new Date(prevYear, prevMonth, 0).getDate();

    const lastDay = new Date(prevYear, prevMonth - 1, prevMonthDays);

    try {
      const previousSchedule = await this.prisma.shiftSchedule.findFirst({
        where: {
          branchId,
          month: prevMonth,
          year: prevYear,
        },
        include: {
          shiftAssignments: {
            where: {
              date: lastDay,
            },
            include: {
              staffProfile: true,
            },
          },
        },
      });

      this.previousMonthLastAssignments.clear();

      if (previousSchedule?.shiftAssignments) {
        for (const assignment of previousSchedule.shiftAssignments) {
          this.previousMonthLastAssignments.set(assignment.staffProfileId, {
            date: assignment.date,
            shiftType: assignment.shiftType,
          });
        }

        console.log(`Loaded ${this.previousMonthLastAssignments.size} assignments from previous month for continuity`);
      }
    } catch (error) {
      console.log('No previous month schedule found');
    }
  }

  /**
   * Calculate weekend days
   */
  private calculateWeekends(): void {
    this.weekends = [];

    for (let day = 1; day <= this.daysInMonth; day++) {
      const date = new Date(this.year, this.month - 1, day);
      const dayOfWeek = date.getDay();

      if (dayOfWeek === 0 || dayOfWeek === 6) {
        // Sunday or Saturday
        this.weekends.push(day);
      }
    }

    console.log(`Calculated ${this.weekends.length} weekend days`);
  }

  /**
   * Mark holiday days
   */
  private markHolidayDays(holidayDates: Date[]): void {
    this.holidays.clear();

    for (const holiday of holidayDates) {
      if (
        holiday.getMonth() + 1 === this.month &&
        holiday.getFullYear() === this.year
      ) {
        this.holidays.add(holiday.getDate());
      }
    }

    console.log(`Marked ${this.holidays.size} holidays`);
  }

  /**
   * Initialize statistics
   */
  private initializeStats(): void {
    this.stats = {};
    for (const staff of this.staff) {
      this.stats[staff.id] = {
        nightWeekdayCount: 0,
        dayWeekendCount: 0,
        nightWeekendCount: 0,
        standbyOnCallCount: 0,
        standbyBranchCount: 0,
        offCount: 0,
        lastNightShift: -10,
      };
    }
  }

  /**
   * Create HOLIDAY assignments for all staff
   */
  private createHolidayAssignments(): void {
    for (const day of Array.from(this.holidays)) {
      for (const staff of this.staff) {
        this.addAssignment(staff.id, day, ShiftType.HOLIDAY);
      }
    }
  }

  /**
   * Create LEAVE assignments
   */
  private createLeaveAssignments(): void {
    for (const [staffId, leaveDates] of this.leaveRequests.entries()) {
      for (const leaveDate of leaveDates) {
        // Use UTC methods for consistent date handling
        const leaveDateUTC = new Date(leaveDate);
        leaveDateUTC.setUTCHours(0, 0, 0, 0);

        if (
          leaveDateUTC.getUTCMonth() === this.month - 1 &&
          leaveDateUTC.getUTCFullYear() === this.year
        ) {
          this.addAssignment(staffId, leaveDateUTC.getUTCDate(), ShiftType.LEAVE);
          console.log(`✓ Created LEAVE assignment for staff ${staffId} on day ${leaveDateUTC.getUTCDate()}`);
        }
      }
    }
  }

  /**
   * Generate shifts for a single day
   */
  private generateDayShifts(day: number): void {
    const isWeekend = this.weekends.includes(day);
    const isHoliday = this.holidays.has(day);

    const date = new Date(this.year, this.month - 1, day);
    const dayOfWeek = date.getDay();

    // Check continuity: if any staff worked NIGHT_WEEKDAY on last day of previous month
    if (day === 1) {
      this.handleMonthContinuity();
    }

    // Treat holidays as weekends - use weekend shift types
    if (isWeekend || isHoliday) {
      // Weekend/Holiday shifts
      this.assignDayWeekendShift(day);
      this.assignNightWeekendShift(day);
    } else {
      // Weekday shifts
      this.assignNightWeekdayShift(day, dayOfWeek);
    }

    // Everyday shifts
    this.assignStandbyOnCallShift(day);
    this.assignStandbyBranchShift(day);
  }

  /**
   * Handle month continuity - give OFF to staff who worked NIGHT_WEEKDAY on last day of prev month
   */
  private handleMonthContinuity(): void {
    for (const [staffId, lastAssignment] of this.previousMonthLastAssignments.entries()) {
      if (lastAssignment.shiftType === 'NIGHT_WEEKDAY') {
        // Give them OFF on day 1
        if (!this.isAssigned(staffId, 1)) {
          this.addAssignment(staffId, 1, ShiftType.OFF);
          this.stats[staffId].offCount++;
          console.log(`Continuity: ${staffId} gets OFF on day 1 (worked NIGHT_WEEKDAY on last day of prev month)`);
        }
      }
    }
  }

  /**
   * Assign NIGHT_WEEKDAY shift (weekdays only)
   */
  private assignNightWeekdayShift(day: number, dayOfWeek: number): void {
    const eligible = this.staff.filter((staff) => {
      if (!staff.canWorkType1) return false;
      if (this.isAssigned(staff.id, day)) return false;
      if (this.isOnLeave(staff.id, day)) return false;

      // Sabbath restriction (Friday=5, Saturday=6)
      if (staff.hasSabbathRestriction && (dayOfWeek === 5 || dayOfWeek === 6)) {
        return false;
      }

      // Check minimum gap
      const daysSinceLastNight = day - this.stats[staff.id].lastNightShift;
      if (daysSinceLastNight < staff.minDaysBetweenNightShifts) {
        return false;
      }

      // Check max night shifts
      if (this.stats[staff.id].nightWeekdayCount >= staff.maxNightShiftsPerMonth) {
        return false;
      }

      return true;
    });

    if (eligible.length === 0) {
      console.warn(`No eligible staff for NIGHT_WEEKDAY on day ${day}`);
      return;
    }

    // Sort by count (fairness)
    eligible.sort((a, b) => {
      const countDiff = this.stats[a.id].nightWeekdayCount - this.stats[b.id].nightWeekdayCount;
      if (countDiff !== 0) return countDiff;

      // Prefer server access
      if (a.hasServerAccess && !b.hasServerAccess) return -1;
      if (!a.hasServerAccess && b.hasServerAccess) return 1;

      return 0;
    });

    const selected = eligible[0];
    this.addAssignment(selected.id, day, ShiftType.NIGHT_WEEKDAY);
    this.stats[selected.id].nightWeekdayCount++;
    this.stats[selected.id].lastNightShift = day;

    // PAIRING RULE:
    // - If server staff got night shift → NO Type 4 needed (server already covering)
    // - If non-server staff got night shift → Type 4 IS needed (mark for server standby)
    if (selected.hasServerAccess) {
      // Server staff on night shift - no standby needed
      console.log(`✓ Server staff assigned to NIGHT_WEEKDAY on day ${day} - no standby required`);
      // Remove from standby requirement if it was previously added
      this.daysNeedingServerStandby.delete(day);
    } else {
      // Non-server staff on night shift - server standby required
      this.daysNeedingServerStandby.add(day);
      console.log(`⚠️  Non-server staff assigned to NIGHT_WEEKDAY on day ${day} - server standby required`);
    }

    // Auto OFF day H+1 (only for NIGHT_WEEKDAY)
    const nextDay = day + 1;
    if (
      nextDay <= this.daysInMonth &&
      !this.holidays.has(nextDay) &&
      !this.isAssigned(selected.id, nextDay)
    ) {
      this.addAssignment(selected.id, nextDay, ShiftType.OFF);
      this.stats[selected.id].offCount++;
    }
  }

  /**
   * Assign DAY_WEEKEND shift (weekends/holidays only)
   * RULE: Only non-server staff can work DAY_WEEKEND
   */
  private assignDayWeekendShift(day: number): void {
    const eligible = this.staff.filter((staff) => {
      if (!staff.canWorkType2) return false;
      if (this.isAssigned(staff.id, day)) return false;
      if (this.isOnLeave(staff.id, day)) return false;

      // Server staff CANNOT work DAY_WEEKEND shifts
      if (staff.hasServerAccess) return false;

      return true;
    });

    if (eligible.length === 0) {
      console.warn(`No eligible staff for DAY_WEEKEND on day ${day}`);
      return;
    }

    // Sort by count
    eligible.sort((a, b) => this.stats[a.id].dayWeekendCount - this.stats[b.id].dayWeekendCount);

    const selected = eligible[0];
    this.addAssignment(selected.id, day, ShiftType.DAY_WEEKEND);
    this.stats[selected.id].dayWeekendCount++;
  }

  /**
   * Assign NIGHT_WEEKEND shift (weekends/holidays only)
   */
  private assignNightWeekendShift(day: number): void {
    const date = new Date(this.year, this.month - 1, day);
    const dayOfWeek = date.getDay();

    const eligible = this.staff.filter((staff) => {
      if (!staff.canWorkType3) return false;
      if (this.isAssigned(staff.id, day)) return false;
      if (this.isOnLeave(staff.id, day)) return false;

      // Sabbath restriction
      if (staff.hasSabbathRestriction && (dayOfWeek === 5 || dayOfWeek === 6)) {
        return false;
      }

      return true;
    });

    if (eligible.length === 0) {
      console.warn(`No eligible staff for NIGHT_WEEKEND on day ${day}`);
      return;
    }

    // Sort by count
    eligible.sort((a, b) => this.stats[a.id].nightWeekendCount - this.stats[b.id].nightWeekendCount);

    const selected = eligible[0];
    this.addAssignment(selected.id, day, ShiftType.NIGHT_WEEKEND);
    this.stats[selected.id].nightWeekendCount++;
    this.stats[selected.id].lastNightShift = day;

    // PAIRING RULE:
    // - If server staff got night shift → NO Type 4 needed (server already covering)
    // - If non-server staff got night shift → Type 4 IS needed (mark for server standby)
    if (selected.hasServerAccess) {
      // Server staff on night shift - no standby needed
      console.log(`✓ Server staff assigned to NIGHT_WEEKEND on day ${day} - no standby required`);
      // Remove from standby requirement if it was previously added
      this.daysNeedingServerStandby.delete(day);
    } else {
      // Non-server staff on night shift - server standby required
      this.daysNeedingServerStandby.add(day);
      console.log(`⚠️  Non-server staff assigned to NIGHT_WEEKEND on day ${day} - server standby required`);
    }

    // Auto OFF day H+1 (for NIGHT_WEEKEND)
    const nextDay = day + 1;
    if (
      nextDay <= this.daysInMonth &&
      !this.holidays.has(nextDay) &&
      !this.isAssigned(selected.id, nextDay)
    ) {
      this.addAssignment(selected.id, nextDay, ShiftType.OFF);
      this.stats[selected.id].offCount++;
    }
  }

  /**
   * Assign STANDBY_ONCALL shift (everyday)
   * RULE: Only server staff can work STANDBY_ONCALL
   * RULE: Skip if server staff already has night shift that day
   * PRIORITY: Required when non-server staff has night shift
   */
  private assignStandbyOnCallShift(day: number): void {
    // Skip if server staff already has night shift this day (no standby needed)
    if (!this.daysNeedingServerStandby.has(day)) {
      console.log(`⊝ Skipping STANDBY_ONCALL on day ${day} - server staff already covering night shift`);
      return;
    }

    const eligible = this.staff.filter((staff) => {
      if (!staff.canWorkType4) return false;
      if (this.isAssigned(staff.id, day)) return false;
      if (this.isOnLeave(staff.id, day)) return false;

      // ONLY server staff can work STANDBY_ONCALL
      if (!staff.hasServerAccess) return false;

      return true;
    });

    if (eligible.length === 0) {
      console.error(`⚠️  CRITICAL: No server staff available for STANDBY_ONCALL on day ${day} (required due to non-server night shift)`);
      return;
    }

    // Sort by count
    eligible.sort((a, b) => this.stats[a.id].standbyOnCallCount - this.stats[b.id].standbyOnCallCount);

    const selected = eligible[0];
    this.addAssignment(selected.id, day, ShiftType.STANDBY_ONCALL);
    this.stats[selected.id].standbyOnCallCount++;

    console.log(`✓ Server standby requirement fulfilled for day ${day} (non-server has night shift)`);
  }

  /**
   * Assign STANDBY_BRANCH shift (everyday)
   * RULE: Only non-server staff can work STANDBY_BRANCH
   */
  private assignStandbyBranchShift(day: number): void {
    const eligible = this.staff.filter((staff) => {
      if (!staff.canWorkType5) return false;
      if (this.isAssigned(staff.id, day)) return false;
      if (this.isOnLeave(staff.id, day)) return false;

      // Server staff CANNOT work STANDBY_BRANCH shifts
      if (staff.hasServerAccess) return false;

      return true;
    });

    if (eligible.length === 0) {
      console.warn(`No eligible staff for STANDBY_BRANCH on day ${day}`);
      return;
    }

    // Sort by count
    eligible.sort((a, b) => this.stats[a.id].standbyBranchCount - this.stats[b.id].standbyBranchCount);

    const selected = eligible[0];
    this.addAssignment(selected.id, day, ShiftType.STANDBY_BRANCH);
    this.stats[selected.id].standbyBranchCount++;
  }

  /**
   * Check if staff is on leave
   */
  private isOnLeave(staffId: string, day: number): boolean {
    const leaveDates = this.leaveRequests.get(staffId);
    if (!leaveDates) return false;

    // Use UTC date comparison to avoid timezone issues
    const checkDate = new Date(Date.UTC(this.year, this.month - 1, day));

    return leaveDates.some(
      (leaveDate) => {
        const leaveDateUTC = new Date(leaveDate);
        leaveDateUTC.setUTCHours(0, 0, 0, 0);

        return (
          leaveDateUTC.getUTCDate() === day &&
          leaveDateUTC.getUTCMonth() === this.month - 1 &&
          leaveDateUTC.getUTCFullYear() === this.year
        );
      }
    );
  }

  /**
   * Check if staff is already assigned
   */
  private isAssigned(staffId: string, day: number): boolean {
    // Use UTC date to match addAssignment
    const date = new Date(Date.UTC(this.year, this.month - 1, day, 0, 0, 0, 0));
    return this.assignments.some(
      (a) => a.staffProfileId === staffId && a.date.getTime() === date.getTime()
    );
  }

  /**
   * Add assignment
   */
  private addAssignment(staffId: string, day: number, shiftType: ShiftType): void {
    // Use UTC date to ensure consistent storage and querying
    const date = new Date(Date.UTC(this.year, this.month - 1, day, 0, 0, 0, 0));
    this.assignments.push({
      staffProfileId: staffId,
      date,
      shiftType,
      isAutoGenerated: true,
    });
  }

  /**
   * Print generation statistics
   */
  private printStats(): void {
    for (const [staffId, stats] of Object.entries(this.stats)) {
      const staff = this.staff.find((s) => s.id === staffId);
      if (!staff) continue;

      console.log(`${staff.userId}: NW=${stats.nightWeekdayCount} DW=${stats.dayWeekendCount} NWE=${stats.nightWeekendCount} OC=${stats.standbyOnCallCount} BR=${stats.standbyBranchCount} OFF=${stats.offCount}`);
    }
  }
}
