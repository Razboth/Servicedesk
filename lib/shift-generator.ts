/**
 * Shift Generation Algorithm
 *
 * Generates monthly shift schedules following complex rotation rules:
 * - Weekday night shifts: 1 staff per night
 * - Weekend day shifts: 2 staff for Saturday, 2 for Sunday
 * - Weekend night shifts: 1 staff for Saturday night, 1 for Sunday night
 * - Sunday night shift = Monday off (mandatory)
 * - Night shifts require off-day after
 * - Sabbath restrictions (no Friday night/Saturday for specific staff)
 * - Server access requirements with on-call backup
 * - Fair rotation distribution
 * - Minimum 3-day gap between night shifts
 * - Target 5 night shifts per person per month
 * - Leave requests are respected (staff on leave cannot be assigned)
 */

import { PrismaClient, ShiftType, StaffShiftType } from '@prisma/client';

interface StaffMember {
  id: string;
  userId: string;
  canWorkNightShift: boolean;
  canWorkWeekendDay: boolean;
  hasServerAccess: boolean;
  hasSabbathRestriction: boolean;
  preferredShiftType: StaffShiftType | null;
  maxNightShiftsPerMonth: number;
  minDaysBetweenNightShifts: number;
}

interface ShiftAssignmentData {
  staffProfileId: string;
  date: Date;
  shiftType: ShiftType;
  isAutoGenerated: boolean;
}

interface OnCallAssignmentData {
  staffProfileId: string;
  date: Date;
  reason: string;
}

interface GenerationStats {
  [staffId: string]: {
    nightCount: number;
    weekendDayCount: number;
    offCount: number;
    onCallCount: number;
    lastNightShift: number; // Day of month
  };
}

interface WeekendRotation {
  saturdayDay: string[];
  sundayDay: string[];
  saturdayNight: string[];
  sundayNight: string[];
}

export class ShiftGenerator {
  private prisma: PrismaClient;
  private staff: StaffMember[] = [];
  private stats: GenerationStats = {};
  private assignments: ShiftAssignmentData[] = [];
  private onCallAssignments: OnCallAssignmentData[] = [];
  private leaveRequests: Map<string, Date[]> = new Map(); // staffId -> array of leave dates
  private month: number;
  private year: number;
  private daysInMonth: number;
  private weekends: number[] = [];
  private fridays: number[] = [];
  private saturdays: number[] = [];

  constructor(prisma: PrismaClient) {
    this.prisma = prisma;
    this.month = 0;
    this.year = 0;
    this.daysInMonth = 0;
  }

  /**
   * Generate complete shift schedule for a month
   */
  async generateSchedule(
    branchId: string,
    month: number,
    year: number,
    holidays: Date[] = []
  ): Promise<{
    assignments: ShiftAssignmentData[];
    onCallAssignments: OnCallAssignmentData[];
    stats: GenerationStats;
  }> {
    this.month = month;
    this.year = year;
    this.daysInMonth = new Date(year, month, 0).getDate();

    // Calculate weekends and special days
    this.calculateSpecialDays();

    // Load active staff members for the branch
    await this.loadStaffMembers(branchId);

    if (this.staff.length === 0) {
      throw new Error('No active staff members found for this branch');
    }

    // Load approved leave requests for this month
    await this.loadLeaveRequests(branchId);

    // Initialize statistics
    this.initializeStats();

    // Step 1: Mark holidays
    this.markHolidays(holidays);

    // Step 2: Assign weekend shifts
    this.assignWeekendShifts();

    // Step 3: Distribute weekday night shifts
    this.distributeWeekdayNightShifts();

    // Step 4: Generate on-call backup assignments
    this.generateOnCallBackup();

    return {
      assignments: this.assignments,
      onCallAssignments: this.onCallAssignments,
      stats: this.stats,
    };
  }

  /**
   * Load staff members eligible for shifts
   */
  private async loadStaffMembers(branchId: string): Promise<void> {
    const profiles = await this.prisma.staffShiftProfile.findMany({
      where: {
        branchId,
        isActive: true,
        OR: [
          { canWorkNightShift: true },
          { canWorkWeekendDay: true },
        ],
      },
      include: {
        user: true,
      },
    });

    this.staff = profiles.map((p) => ({
      id: p.id,
      userId: p.userId,
      canWorkNightShift: p.canWorkNightShift,
      canWorkWeekendDay: p.canWorkWeekendDay,
      hasServerAccess: p.hasServerAccess,
      hasSabbathRestriction: p.hasSabbathRestriction,
      preferredShiftType: p.preferredShiftType,
      maxNightShiftsPerMonth: p.maxNightShiftsPerMonth,
      minDaysBetweenNightShifts: p.minDaysBetweenNightShifts,
    }));
  }

  /**
   * Load approved leave requests for this month
   */
  private async loadLeaveRequests(branchId: string): Promise<void> {
    const monthStart = new Date(this.year, this.month - 1, 1);
    const monthEnd = new Date(this.year, this.month, 0);

    const leaveRequests = await this.prisma.leaveRequest.findMany({
      where: {
        staffProfile: {
          branchId,
        },
        status: 'APPROVED',
        OR: [
          {
            AND: [
              { startDate: { lte: monthEnd } },
              { endDate: { gte: monthStart } },
            ],
          },
        ],
      },
      include: {
        staffProfile: true,
      },
    });

    // Map staff IDs to their leave dates
    this.leaveRequests.clear();
    for (const leave of leaveRequests) {
      const leaveDates: Date[] = [];
      const currentDate = new Date(Math.max(leave.startDate.getTime(), monthStart.getTime()));
      const endDate = new Date(Math.min(leave.endDate.getTime(), monthEnd.getTime()));

      while (currentDate <= endDate) {
        leaveDates.push(new Date(currentDate));
        currentDate.setDate(currentDate.getDate() + 1);
      }

      const existingLeaves = this.leaveRequests.get(leave.staffProfileId) || [];
      this.leaveRequests.set(leave.staffProfileId, [...existingLeaves, ...leaveDates]);
    }
  }

  /**
   * Check if staff is on leave on a specific day
   */
  private isOnLeave(staffId: string, day: number): boolean {
    const leaveDates = this.leaveRequests.get(staffId);
    if (!leaveDates) return false;

    const checkDate = new Date(this.year, this.month - 1, day);
    return leaveDates.some(
      (leaveDate) =>
        leaveDate.getDate() === day &&
        leaveDate.getMonth() === this.month - 1 &&
        leaveDate.getFullYear() === this.year
    );
  }

  /**
   * Calculate special days in the month
   */
  private calculateSpecialDays(): void {
    this.weekends = [];
    this.fridays = [];
    this.saturdays = [];

    for (let day = 1; day <= this.daysInMonth; day++) {
      const date = new Date(this.year, this.month - 1, day);
      const dayOfWeek = date.getDay();

      if (dayOfWeek === 5) {
        // Friday
        this.fridays.push(day);
      } else if (dayOfWeek === 6) {
        // Saturday
        this.saturdays.push(day);
        this.weekends.push(day);
      } else if (dayOfWeek === 0) {
        // Sunday
        this.weekends.push(day);
      }
    }
  }

  /**
   * Initialize statistics tracking for all staff
   */
  private initializeStats(): void {
    this.stats = {};
    for (const staff of this.staff) {
      this.stats[staff.id] = {
        nightCount: 0,
        weekendDayCount: 0,
        offCount: 0,
        onCallCount: 0,
        lastNightShift: -10, // Initialize to allow immediate assignment
      };
    }
  }

  /**
   * Mark holidays in the schedule
   */
  private markHolidays(holidays: Date[]): void {
    for (const holiday of holidays) {
      const day = holiday.getDate();
      if (
        holiday.getMonth() + 1 === this.month &&
        holiday.getFullYear() === this.year
      ) {
        // Mark as holiday for all staff
        for (const staff of this.staff) {
          this.addAssignment(staff.id, day, ShiftType.HOLIDAY);
        }
      }
    }
  }

  /**
   * Assign weekend shifts following rotation rules
   */
  private assignWeekendShifts(): void {
    const weekendDayStaff = this.staff.filter((s) => s.canWorkWeekendDay);
    const nightStaff = this.staff.filter((s) => s.canWorkNightShift);
    const nightStaffNoSabbath = nightStaff.filter((s) => !s.hasSabbathRestriction);

    // Group weekends as Saturday-Sunday pairs
    const weekendPairs: [number, number][] = [];
    for (let i = 0; i < this.saturdays.length; i++) {
      const saturday = this.saturdays[i];
      const sunday = saturday + 1;
      if (sunday <= this.daysInMonth) {
        weekendPairs.push([saturday, sunday]);
      }
    }

    // Rotate weekend day staff (2 per day)
    let dayRotationIndex = 0;
    for (const [saturday, sunday] of weekendPairs) {
      if (this.isHoliday(saturday) || this.isHoliday(sunday)) continue;

      // Saturday day shift - 2 staff
      for (let i = 0; i < 2 && i < weekendDayStaff.length; i++) {
        const staffIndex = (dayRotationIndex + i) % weekendDayStaff.length;
        const staff = weekendDayStaff[staffIndex];

        if (!this.isAssigned(staff.id, saturday) && !this.isOnLeave(staff.id, saturday)) {
          this.addAssignment(staff.id, saturday, ShiftType.WEEKEND_DAY);
          this.stats[staff.id].weekendDayCount++;

          // Add off day after weekend day shift
          if (sunday <= this.daysInMonth && !this.isAssigned(staff.id, sunday)) {
            this.addAssignment(staff.id, sunday, ShiftType.OFF);
            this.stats[staff.id].offCount++;
          }
        }
      }

      // Sunday day shift - 2 staff (different from Saturday)
      for (let i = 0; i < 2 && i < weekendDayStaff.length; i++) {
        const staffIndex = (dayRotationIndex + i + 2) % weekendDayStaff.length;
        const staff = weekendDayStaff[staffIndex];

        if (!this.isAssigned(staff.id, sunday) && !this.isOnLeave(staff.id, sunday)) {
          this.addAssignment(staff.id, sunday, ShiftType.WEEKEND_DAY);
          this.stats[staff.id].weekendDayCount++;

          // Add off day after
          if (sunday + 1 <= this.daysInMonth && !this.isAssigned(staff.id, sunday + 1)) {
            this.addAssignment(staff.id, sunday + 1, ShiftType.OFF);
            this.stats[staff.id].offCount++;
          }
        }
      }

      dayRotationIndex += 2;

      // Saturday night shift - 1 staff (NO SABBATH restriction!)
      const satNightStaff = nightStaffNoSabbath.find(staff =>
        !this.isAssigned(staff.id, saturday) && this.canWorkNightShift(staff.id, saturday)
      );

      if (satNightStaff) {
        this.addAssignment(satNightStaff.id, saturday, ShiftType.WEEKEND_NIGHT);
        this.stats[satNightStaff.id].nightCount++;
        this.stats[satNightStaff.id].lastNightShift = saturday;

        // Add off day after night shift
        if (sunday <= this.daysInMonth && !this.isAssigned(satNightStaff.id, sunday)) {
          this.addAssignment(satNightStaff.id, sunday, ShiftType.OFF);
          this.stats[satNightStaff.id].offCount++;
        }
      }

      // Sunday night shift - 1 staff (Sabbath staff CAN work Sunday)
      const sunNightStaff = nightStaff.find(staff =>
        !this.isAssigned(staff.id, sunday) && this.canWorkNightShift(staff.id, sunday)
      );

      if (sunNightStaff) {
        this.addAssignment(sunNightStaff.id, sunday, ShiftType.WEEKEND_NIGHT);
        this.stats[sunNightStaff.id].nightCount++;
        this.stats[sunNightStaff.id].lastNightShift = sunday;

        // Sunday night = Monday off (mandatory rule)
        const monday = sunday + 1;
        if (monday <= this.daysInMonth && !this.isAssigned(sunNightStaff.id, monday)) {
          this.addAssignment(sunNightStaff.id, monday, ShiftType.OFF);
          this.stats[sunNightStaff.id].offCount++;
        }
      }
    }
  }

  /**
   * Distribute weekday night shifts fairly
   */
  private distributeWeekdayNightShifts(): void {
    const nightStaff = this.staff.filter((s) => s.canWorkNightShift);

    for (let day = 1; day <= this.daysInMonth; day++) {
      // Skip weekends and holidays
      if (this.weekends.includes(day) || this.isHoliday(day)) continue;

      // Find eligible staff for this night shift
      const eligible = nightStaff.filter((staff) => {
        return this.canWorkNightShift(staff.id, day);
      });

      if (eligible.length === 0) continue;

      // Sort by night count (assign to person with fewest nights)
      eligible.sort((a, b) => {
        const countDiff = this.stats[a.id].nightCount - this.stats[b.id].nightCount;
        if (countDiff !== 0) return countDiff;

        // If equal, prefer staff with server access on critical days
        if ([1, 15, this.daysInMonth].includes(day)) {
          if (a.hasServerAccess && !b.hasServerAccess) return -1;
          if (!a.hasServerAccess && b.hasServerAccess) return 1;
        }

        return 0;
      });

      const selected = eligible[0];

      // Assign night shift
      this.addAssignment(selected.id, day, ShiftType.NIGHT);
      this.stats[selected.id].nightCount++;
      this.stats[selected.id].lastNightShift = day;

      // Add mandatory off day after night shift
      if (day + 1 <= this.daysInMonth && !this.weekends.includes(day + 1) && !this.isAssigned(selected.id, day + 1)) {
        this.addAssignment(selected.id, day + 1, ShiftType.OFF);
        this.stats[selected.id].offCount++;
      }
    }
  }

  /**
   * Generate on-call backup for shifts without server access
   */
  private generateOnCallBackup(): void {
    const serverAccessStaff = this.staff.filter((s) => s.hasServerAccess);

    if (serverAccessStaff.length === 0) return;

    let onCallIndex = 0;

    for (let day = 1; day <= this.daysInMonth; day++) {
      // Find shifts that need on-call backup
      const dayAssignments = this.assignments.filter((a) => {
        const date = new Date(this.year, this.month - 1, day);
        return a.date.getTime() === date.getTime();
      });

      for (const assignment of dayAssignments) {
        const staff = this.staff.find((s) => s.id === assignment.staffProfileId);
        if (!staff) continue;

        // Weekend day shifts always need on-call (no server access)
        // Night shifts without server access need on-call
        let needsOnCall = false;
        let reason = '';

        if (assignment.shiftType === ShiftType.WEEKEND_DAY) {
          needsOnCall = true;
          reason = 'Weekend day shift - no server access staff';
        } else if (
          (assignment.shiftType === ShiftType.NIGHT || assignment.shiftType === ShiftType.WEEKEND_NIGHT) &&
          !staff.hasServerAccess
        ) {
          needsOnCall = true;
          reason = `${assignment.shiftType === ShiftType.WEEKEND_NIGHT ? 'Weekend' : 'Weekday'} night shift - staff lacks server access`;
        }

        if (needsOnCall) {
          // Find available on-call staff
          const available = serverAccessStaff.filter((s) => {
            const isNotOnShift = !dayAssignments.some(
              (a) => a.staffProfileId === s.id &&
              [ShiftType.NIGHT, ShiftType.WEEKEND_NIGHT, ShiftType.WEEKEND_DAY].includes(a.shiftType)
            );
            const isNotOff = !dayAssignments.some(
              (a) => a.staffProfileId === s.id && a.shiftType === ShiftType.OFF
            );
            return isNotOnShift && isNotOff;
          });

          if (available.length > 0) {
            const onCall = available[onCallIndex % available.length];

            this.onCallAssignments.push({
              staffProfileId: onCall.id,
              date: new Date(this.year, this.month - 1, day),
              reason,
            });

            this.stats[onCall.id].onCallCount++;
            onCallIndex++;
          }
        }
      }
    }
  }

  /**
   * Check if staff can work night shift on given day
   */
  private canWorkNightShift(staffId: string, day: number): boolean {
    const staff = this.staff.find((s) => s.id === staffId);
    if (!staff) return false;

    // Check if already assigned
    if (this.isAssigned(staffId, day)) return false;

    // Check if on leave
    if (this.isOnLeave(staffId, day)) return false;

    // Check Sabbath restriction (Friday nights and Saturdays)
    if (staff.hasSabbathRestriction) {
      if (this.fridays.includes(day) || this.saturdays.includes(day)) {
        return false;
      }
    }

    // Check minimum gap between night shifts
    const daysSinceLastNight = day - this.stats[staffId].lastNightShift;
    if (daysSinceLastNight < staff.minDaysBetweenNightShifts) {
      return false;
    }

    // Check if below maximum night shifts per month
    if (this.stats[staffId].nightCount >= staff.maxNightShiftsPerMonth) {
      return false;
    }

    return true;
  }

  /**
   * Check if staff is already assigned on a day
   */
  private isAssigned(staffId: string, day: number): boolean {
    const date = new Date(this.year, this.month - 1, day);
    return this.assignments.some(
      (a) => a.staffProfileId === staffId && a.date.getTime() === date.getTime()
    );
  }

  /**
   * Check if a day is a holiday
   */
  private isHoliday(day: number): boolean {
    const date = new Date(this.year, this.month - 1, day);
    return this.assignments.some(
      (a) => a.date.getTime() === date.getTime() && a.shiftType === ShiftType.HOLIDAY
    );
  }

  /**
   * Add a shift assignment
   */
  private addAssignment(staffId: string, day: number, shiftType: ShiftType): void {
    const date = new Date(this.year, this.month - 1, day);
    this.assignments.push({
      staffProfileId: staffId,
      date,
      shiftType,
      isAutoGenerated: true,
    });
  }
}