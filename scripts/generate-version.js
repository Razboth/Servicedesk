#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// Get git information
function getGitInfo() {
  try {
    // Get current commit hash (short)
    const commitHash = execSync('git rev-parse --short HEAD', { encoding: 'utf8' }).trim();
    
    // Get current branch
    const branch = execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();
    
    // Get commit count (as version number)
    const commitCount = execSync('git rev-list --count HEAD', { encoding: 'utf8' }).trim();
    
    // Get last commit message (only first line for safety)
    const lastCommitMessage = execSync('git log -1 --pretty=%s', { encoding: 'utf8' }).trim();
    
    // Get last commit date
    const lastCommitDate = execSync('git log -1 --pretty=%ci', { encoding: 'utf8' }).trim();
    
    // Check if working directory is clean
    let isDirty = false;
    try {
      execSync('git diff-index --quiet HEAD --');
    } catch {
      isDirty = true;
    }
    
    // Get tag if exists
    let tag = '';
    try {
      tag = execSync('git describe --tags --exact-match', { encoding: 'utf8' }).trim();
    } catch {
      // No tag on current commit
    }
    
    // Get semantic version from package.json
    const packageJson = require('../package.json');
    const semanticVersion = packageJson.version || '1.0.0';
    
    return {
      version: semanticVersion,
      commitHash,
      branch,
      commitCount,
      lastCommitMessage,
      lastCommitDate,
      isDirty,
      tag,
      buildDate: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error getting git info:', error.message);
    // Get version from package.json even if git is not available
    const packageJson = require('../package.json');
    const semanticVersion = packageJson.version || '1.0.0';

    // Return default values if git is not available
    return {
      version: semanticVersion,
      commitHash: 'unknown',
      branch: 'unknown',
      commitCount: '0',
      lastCommitMessage: 'No git information available',
      lastCommitDate: new Date().toISOString(),
      isDirty: false,
      tag: '',
      buildDate: new Date().toISOString()
    };
  }
}

// Generate the version file
function generateVersionFile() {
  const gitInfo = getGitInfo();
  
  const versionContent = `// Auto-generated version information from git
// Generated at: ${new Date().toISOString()}
// DO NOT EDIT THIS FILE MANUALLY - It will be overwritten

export const APP_VERSION = {
  version: '${gitInfo.version}',
  commit: '${gitInfo.commitHash}${gitInfo.isDirty ? '-dirty' : ''}',
  branch: '${gitInfo.branch}',
  buildNumber: ${gitInfo.commitCount},
  buildDate: '${gitInfo.buildDate.split('T')[0]}',
  environment: process.env.NODE_ENV || 'development',
  copyright: 'Â© 2025 Bank SulutGo',
  lastCommit: {
    message: \`${gitInfo.lastCommitMessage.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`,
    date: '${gitInfo.lastCommitDate}',
    hash: '${gitInfo.commitHash}'
  },
  isDirty: ${gitInfo.isDirty},
  tag: '${gitInfo.tag}'
};

// Get formatted version string
export function getVersionString(): string {
  const { version, commit, branch, isDirty } = APP_VERSION;
  const env = process.env.NODE_ENV || 'development';
  
  // Format: v{version}-{commit}[-dirty] ({branch})
  let versionStr = \`v\${version}-\${commit}\`;
  
  if (env === 'development' && branch !== 'main' && branch !== 'master') {
    versionStr += \` (\${branch})\`;
  }
  
  return versionStr;
}

// Get full version info for debugging
export function getFullVersionInfo(): string {
  const { version, commit, branch, buildNumber, buildDate, isDirty } = APP_VERSION;
  return \`Version \${version} | Build #\${buildNumber} | Commit: \${commit}\${isDirty ? '-dirty' : ''} | Branch: \${branch} | Built: \${buildDate}\`;
}

// Get commit info
export function getCommitInfo(): string {
  const { lastCommit } = APP_VERSION;
  const date = new Date(lastCommit.date);
  const formattedDate = date.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'short', 
    day: 'numeric' 
  });
  return \`\${lastCommit.message.substring(0, 50)}\${lastCommit.message.length > 50 ? '...' : ''} (\${formattedDate})\`;
}

// Version history based on commit messages
export const VERSION_HISTORY = [
  {
    version: APP_VERSION.version,
    date: APP_VERSION.buildDate,
    commit: APP_VERSION.commit,
    message: APP_VERSION.lastCommit.message
  }
];
`;

  // Write the file
  const outputPath = path.join(__dirname, '..', 'lib', 'version.ts');
  fs.writeFileSync(outputPath, versionContent, 'utf8');
  
  console.log('âœ… Version file generated successfully!');
  console.log(`ğŸ“‹ Version: ${gitInfo.version}`);
  console.log(`ğŸ”§ Commit: ${gitInfo.commitHash}${gitInfo.isDirty ? '-dirty' : ''}`);
  console.log(`ğŸŒ¿ Branch: ${gitInfo.branch}`);
  console.log(`ğŸ“¦ Build: #${gitInfo.commitCount}`);
  console.log(`ğŸ“ Last commit: ${gitInfo.lastCommitMessage}`);
}

// Run the generator
generateVersionFile();