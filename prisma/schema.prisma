generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                 @id @default(cuid())
  email                  String                 @unique
  name                   String
  password               String?
  role                   UserRole               @default(USER)
  branchId               String?
  isActive               Boolean                @default(true)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  phone                  String?
  avatar                 String?                // Avatar identifier or URL
  supportGroupId         String?
  lastActivity           DateTime               @default(now())
  lastLoginAttempt       DateTime?
  lockedAt               DateTime?
  loginAttempts          Int                    @default(0)
  username               String                 @unique
  isFirstLogin           Boolean                @default(true)
  mustChangePassword     Boolean                @default(true)
  passwordChangedAt      DateTime?

  // Email notification preferences
  emailNotifyOnTicketCreated  Boolean @default(true)
  emailNotifyOnTicketAssigned Boolean @default(true)
  emailNotifyOnTicketUpdated  Boolean @default(true)
  emailNotifyOnTicketResolved Boolean @default(true)
  emailNotifyOnComment        Boolean @default(true)

  createdApiKeys         ApiKey[]               @relation("ApiKeyCreatedBy")
  linkedApiKeys          ApiKey[]               @relation("ApiKeyLinkedUser")
  accounts               Account[]
  verifiedClaims         ATMClaimVerification[]
  auditLogs              AuditLog[]
  createdBranchTasks     BranchAssignment[]     @relation("AssignedByBranchTasks")
  assignedBranchTasks    BranchAssignment[]     @relation("AssignedBranchTasks")
  branchCommunications   BranchCommunication[]
  createdReports         CustomReport[]         @relation("ReportCreator")
  knowledgeArticles      KnowledgeArticle[]
  knowledgeAttachments   KnowledgeAttachment[]
  knowledgeComments      KnowledgeComment[]
  knowledgeFeedback      KnowledgeFeedback[]
  knowledgeVersions      KnowledgeVersion[]
  assignedLegacyTickets  LegacyTicket[]         @relation("LegacyTicketAssignee")
  convertedLegacyTickets LegacyTicket[]         @relation("LegacyTicketConverter")
  createdLegacyTickets   LegacyTicket[]         @relation("LegacyTicketCreator")
  notifications          Notification[]
  executedReports        ReportExecution[]      @relation("ReportExecutor")
  favoriteReports        ReportFavorite[]       @relation("ReportFavorites")
  serviceUsage           ServiceUsage[]
  sessions               Session[]
  approvals              TicketApproval[]
  comments               TicketComment[]
  ticketKnowledge        TicketKnowledge[]
  completedTasks         TicketTask[]
  assignedTickets        Ticket[]               @relation("TicketAssignee")
  createdTickets         Ticket[]               @relation("TicketCreator")
  favoriteCategories     UserFavoriteCategory[]
  favoriteServices       UserFavoriteService[]
  assignedVendorTickets  VendorTicket[]         @relation("VendorTicketAssignedBy")
  assignedPCAssets       PCAsset[]              @relation("AssignedPCAssets")
  createdPCAssets        PCAsset[]              @relation("CreatedPCAssets")
  pcServiceLogs          PCServiceLog[]
  hardeningChecklists    HardeningChecklist[]
  assignedOSLicenses     OSLicense[]            @relation("OSLicenseAssignedUser")
  createdOSLicenses      OSLicense[]            @relation("OSLicenseCreatedBy")
  assignedOfficeLicenses OfficeLicense[]        @relation("OfficeLicenseAssignedUser")
  createdOfficeLicenses  OfficeLicense[]        @relation("OfficeLicenseCreatedBy")
  assignedAntivirusLicenses AntivirusLicense[]  @relation("AntivirusLicenseAssignedUser")
  createdOperatingSystems OperatingSystem[]     @relation("OSCreatedBy")
  createdOfficeProducts  OfficeProduct[]        @relation("OfficeCreatedBy")
  passwordResetTokens    PasswordResetToken[]
  dailyTaskLists         DailyTaskList[]

  // Knowledge base collaboration
  knowledgeCollaborations KnowledgeCollaborator[] @relation("CollaboratorUser")
  invitedCollaborators    KnowledgeCollaborator[] @relation("InvitedByUser")
  knowledgeActivities     KnowledgeActivity[]
  knowledgeCommentAttachments KnowledgeCommentAttachment[]
  knowledgeServiceLinks   KnowledgeServiceLink[]  @relation("KnowledgeLinkUser")

  // Announcements
  createdAnnouncements   Announcement[]         @relation("AnnouncementCreator")
  updatedAnnouncements   Announcement[]         @relation("AnnouncementUpdater")
  viewedAnnouncements    AnnouncementView[]

  // Shift management
  shiftProfile           StaffShiftProfile?

  branch                 Branch?                @relation(fields: [branchId], references: [id])
  supportGroup           SupportGroup?          @relation(fields: [supportGroupId], references: [id])

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Branch {
  id                     String                @id @default(cuid())
  name                   String
  code                   String                @unique
  address                String?
  city                   String?
  province               String?
  isActive               Boolean               @default(true)
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  backupIpAddress        String?
  ipAddress              String?
  monitoringEnabled      Boolean               @default(false)
  networkMedia           NetworkMedia?
  networkVendor          String?
  latitude               Float?
  longitude              Float?
  atms                   ATM[]
  branchAssignments      BranchAssignment[]
  sentCommunications     BranchCommunication[] @relation("SentCommunications")
  receivedCommunications BranchCommunication[] @relation("ReceivedCommunications")
  legacyTickets          LegacyTicket[]
  networkIncidents       NetworkIncident[]
  pingResults            NetworkPingResult[]   @relation("BranchPingResults")
  serviceUsage           ServiceUsage[]
  tickets                Ticket[]
  users                  User[]
  pcAssets               PCAsset[]
  osLicenses             OSLicense[]
  officeLicenses         OfficeLicense[]
  antivirusLicenses      AntivirusLicense[]
  announcements          AnnouncementBranch[]
  staffShiftProfiles     StaffShiftProfile[]
  shiftSchedules         ShiftSchedule[]

  @@map("branches")
}

model ServiceCategory {
  id          String                 @id @default(cuid())
  name        String
  description String?
  parentId    String?
  level       Int                    @default(1)
  isActive    Boolean                @default(true)
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @updatedAt
  parent      ServiceCategory?       @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ServiceCategory[]      @relation("CategoryHierarchy")
  services    Service[]
  favoritedBy UserFavoriteCategory[]
  knowledgeLinks KnowledgeServiceLink[]

  @@map("service_categories")
}

model Service {
  id                         String                 @id @default(cuid())
  name                       String
  description                String
  helpText                   String?
  categoryId                 String
  subcategoryId              String?
  itemId                     String?
  priority                   TicketPriority         @default(MEDIUM)
  estimatedHours             Int?                   @default(4)
  slaHours                   Int                    @default(24)
  isActive                   Boolean                @default(true)
  requiresApproval           Boolean                @default(true)
  isConfidential             Boolean                @default(false)
  createdAt                  DateTime               @default(now())
  updatedAt                  DateTime               @updatedAt
  businessHoursOnly          Boolean                @default(true)
  escalationHours            Int?                   @default(48)
  isKasdaService             Boolean                @default(false)
  resolutionHours            Int?                   @default(24)
  responseHours              Int?                   @default(4)
  tier1CategoryId            String?
  tier2SubcategoryId         String?
  tier3ItemId                String?
  defaultIssueClassification IssueClassification?
  defaultItilCategory        TicketCategory?        @default(INCIDENT)
  defaultTitle               String?
  supportGroupId             String?
  legacyTickets              LegacyTicket[]
  reportTemplates            ReportTemplate[]
  fieldTemplates             ServiceFieldTemplate[]
  fields                     ServiceField[]
  usage                      ServiceUsage[]
  knowledgeLinks             KnowledgeServiceLink[]
  category                   ServiceCategory        @relation(fields: [categoryId], references: [id])
  supportGroup               SupportGroup?          @relation(fields: [supportGroupId], references: [id])
  tier1Category              Category?              @relation(fields: [tier1CategoryId], references: [id])
  tier2Subcategory           Subcategory?           @relation(fields: [tier2SubcategoryId], references: [id])
  tier3Item                  Item?                  @relation(fields: [tier3ItemId], references: [id])
  slaTemplate                SLATemplate?
  taskTemplates              TaskTemplate[]
  tickets                    Ticket[]
  favoritedBy                UserFavoriteService[]

  @@index([tier1CategoryId])
  @@index([tier2SubcategoryId])
  @@index([tier3ItemId])
  @@index([supportGroupId])
  @@index([isActive])
  @@index([tier1CategoryId, tier2SubcategoryId, tier3ItemId])
  @@map("services")
}

model ServiceField {
  id            String             @id @default(cuid())
  serviceId     String
  name          String
  label         String
  type          FieldType
  isRequired    Boolean            @default(false)
  isUserVisible Boolean            @default(true)
  placeholder   String?
  helpText      String?
  defaultValue  String?
  options       Json?
  validation    Json?
  order         Int                @default(0)
  isActive      Boolean            @default(true)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  service       Service            @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  fieldValues   TicketFieldValue[]

  @@unique([serviceId, name])
  @@map("service_fields")
}

model FieldTemplate {
  id                    String                 @id @default(cuid())
  name                  String                 @unique
  label                 String
  description           String?
  type                  FieldType
  isRequired            Boolean                @default(false)
  placeholder           String?
  helpText              String?
  defaultValue          String?
  options               Json?
  validation            Json?
  category              String?
  isActive              Boolean                @default(true)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  createdBy             String?
  serviceFieldTemplates ServiceFieldTemplate[]

  @@map("field_templates")
}

model ServiceFieldTemplate {
  id              String        @id @default(cuid())
  serviceId       String
  fieldTemplateId String
  order           Int           @default(0)
  isRequired      Boolean?
  isUserVisible   Boolean       @default(true)
  helpText        String?
  defaultValue    String?
  fieldTemplate   FieldTemplate @relation(fields: [fieldTemplateId], references: [id])
  service         Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([serviceId, fieldTemplateId])
  @@map("service_field_templates")
}

model Ticket {
  id                     String                @id @default(cuid())
  ticketNumber           String                @unique
  title                  String
  description            String
  serviceId              String
  categoryId             String?
  subcategoryId          String?
  itemId                 String?
  priority               TicketPriority        @default(MEDIUM)
  status                 TicketStatus          @default(OPEN)
  createdById            String
  assignedToId           String?
  branchId               String?
  isConfidential         Boolean               @default(false)
  issueClassification    IssueClassification?
  rootCause              String?
  preventiveMeasures     String?
  knowledgeBaseCreated   Boolean               @default(false)
  estimatedHours         Int?
  actualHours            Float?
  resolutionNotes        String?
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  resolvedAt             DateTime?
  closedAt               DateTime?
  category               TicketCategory        @default(INCIDENT)
  securityClassification String?
  securityFindings       Json?
  supportGroupId         String?
  importBatchId          String?
  importedAt             DateTime?
  isLegacy               Boolean               @default(false)
  legacyData             Json?
  legacySystem           String?
  legacyTicketId         String?

  // Omnichannel fields
  sourceChannel          String?               // WhatsApp, Email, Chat, etc.
  channelReferenceId     String?               // External reference from channel
  customerName           String?
  customerEmail          String?
  customerPhone          String?
  customerIdentifier     String?               // CIF, Account number, etc.
  metadata               Json?                 // Additional omnichannel data
  atmClaimVerification   ATMClaimVerification?
  ATMIncident            ATMIncident[]
  auditLogs              AuditLog[]
  branchAssignments      BranchAssignment[]
  branchCommunications   BranchCommunication[]
  legacyTicketMapping    LegacyTicket?         @relation("LegacyTicketMapping")
  networkIncidents       NetworkIncident[]
  omnichannelLogs        OmnichannelLog[]
  serviceUsage           ServiceUsage[]
  slaTracking            SLATracking[]
  approvals              TicketApproval[]
  attachments            TicketAttachment[]
  comments               TicketComment[]
  fieldValues            TicketFieldValue[]
  knowledgeArticles      TicketKnowledge[]
  tasks                  TicketTask[]
  dailyTasks             DailyTask[]
  pcServiceLogs          PCServiceLog[]
  assignedTo             User?                 @relation("TicketAssignee", fields: [assignedToId], references: [id])
  branch                 Branch?               @relation(fields: [branchId], references: [id])
  createdBy              User                  @relation("TicketCreator", fields: [createdById], references: [id])
  migrationBatch         MigrationBatch?       @relation(fields: [importBatchId], references: [id])
  service                Service               @relation(fields: [serviceId], references: [id])
  supportGroup           SupportGroup?         @relation(fields: [supportGroupId], references: [id])
  vendorTickets          VendorTicket[]

  @@index([serviceId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@index([supportGroupId])
  @@index([assignedToId])
  @@index([branchId])
  @@index([createdById])
  @@index([status, priority])
  @@index([serviceId, status])
  @@map("tickets")
}

model TicketFieldValue {
  id       String       @id @default(cuid())
  ticketId String
  fieldId  String
  value    String
  field    ServiceField @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  ticket   Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, fieldId])
  @@index([ticketId])
  @@index([fieldId])
  @@index([fieldId, value])
  @@map("ticket_field_values")
}

model TicketComment {
  id          String              @id @default(cuid())
  ticketId    String
  userId      String
  content     String
  isInternal  Boolean             @default(false)
  createdAt   DateTime            @default(now())
  attachments CommentAttachment[]
  ticket      Ticket              @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User                @relation(fields: [userId], references: [id])

  @@map("ticket_comments")
}

model TicketAttachment {
  id           String   @id @default(cuid())
  ticketId     String
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  createdAt    DateTime @default(now())
  ticket       Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_attachments")
}

model CommentAttachment {
  id           String        @id @default(cuid())
  commentId    String
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  createdAt    DateTime      @default(now())
  comment      TicketComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@map("comment_attachments")
}

model Category {
  id                String             @id @default(cuid())
  name              String
  description       String?
  isActive          Boolean            @default(true)
  order             Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  knowledgeArticles KnowledgeArticle[]
  services          Service[]
  subcategories     Subcategory[]

  @@map("categories")
}

model Subcategory {
  id                String             @id @default(cuid())
  categoryId        String
  name              String
  description       String?
  isActive          Boolean            @default(true)
  order             Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  items             Item[]
  knowledgeArticles KnowledgeArticle[]
  services          Service[]
  category          Category           @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@map("subcategories")
}

model Item {
  id                String             @id @default(cuid())
  subcategoryId     String
  name              String
  description       String?
  isActive          Boolean            @default(true)
  order             Int                @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  subcategory       Subcategory        @relation(fields: [subcategoryId], references: [id], onDelete: Cascade)
  knowledgeArticles KnowledgeArticle[]
  services          Service[]

  @@map("items")
}

model TicketApproval {
  id         String         @id @default(cuid())
  ticketId   String
  approverId String
  status     ApprovalStatus @default(PENDING)
  reason     String?
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  approver   User           @relation(fields: [approverId], references: [id])
  ticket     Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_approvals")
}

model SLATemplate {
  id                String        @id @default(cuid())
  serviceId         String        @unique
  responseHours     Int           @default(4)
  resolutionHours   Int           @default(24)
  escalationHours   Int           @default(48)
  businessHoursOnly Boolean       @default(true)
  isActive          Boolean       @default(true)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  service           Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  slaTracking       SLATracking[]

  @@map("sla_templates")
}

model SLATracking {
  id                   String      @id @default(cuid())
  ticketId             String
  slaTemplateId        String
  responseDeadline     DateTime
  resolutionDeadline   DateTime
  escalationDeadline   DateTime
  responseTime         DateTime?
  resolutionTime       DateTime?
  isResponseBreached   Boolean     @default(false)
  isResolutionBreached Boolean     @default(false)
  isEscalated          Boolean     @default(false)
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt
  slaTemplate          SLATemplate @relation(fields: [slaTemplateId], references: [id])
  ticket               Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("sla_tracking")
}

model ATM {
  id               String              @id @default(cuid())
  code             String              @unique
  name             String
  branchId         String
  ipAddress        String?
  location         String?
  latitude         Float?
  longitude        Float?
  isActive         Boolean             @default(true)
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  networkMedia     NetworkMedia?
  networkVendor    String?
  incidents        ATMIncident[]
  monitoringLogs   ATMMonitoringLog[]
  branch           Branch              @relation(fields: [branchId], references: [id])
  networkIncidents NetworkIncident[]
  pingResults      NetworkPingResult[] @relation("ATMPingResults")

  @@map("atms")
}

model ATMMonitoringLog {
  id           String    @id @default(cuid())
  atmId        String
  status       ATMStatus
  responseTime Float?
  errorMessage String?
  checkedAt    DateTime  @default(now())
  atm          ATM       @relation(fields: [atmId], references: [id], onDelete: Cascade)

  @@map("atm_monitoring_logs")
}

model ATMIncident {
  id                  String           @id @default(cuid())
  atmId               String
  ticketId            String?
  type                IncidentType
  severity            IncidentSeverity
  description         String
  status              IncidentStatus   @default(OPEN)
  detectedAt          DateTime         @default(now())
  resolvedAt          DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt
  externalReferenceId String?
  metrics             Json?
  atm                 ATM              @relation(fields: [atmId], references: [id], onDelete: Cascade)
  ticket              Ticket?          @relation(fields: [ticketId], references: [id])

  @@map("atm_incidents")
}

model Vendor {
  id              String         @id @default(cuid())
  code            String         @unique
  name            String
  contactName     String?
  contactEmail    String?
  contactPhone    String?
  address         String?
  website         String?
  supportHours    String?
  slaResponseTime Int?           // in hours
  slaResolutionTime Int?         // in hours
  notes           String?
  isActive        Boolean        @default(true)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  vendorTickets   VendorTicket[]

  @@map("vendors")
}

model VendorTicket {
  id                 String       @id @default(cuid())
  ticketId           String
  vendorId           String
  vendorTicketNumber String
  assignedById       String
  status             VendorStatus @default(IN_PROGRESS)
  notes              String?
  respondedAt        DateTime?
  resolvedAt         DateTime?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  ticket             Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  vendor             Vendor       @relation(fields: [vendorId], references: [id])
  assignedBy         User         @relation("VendorTicketAssignedBy", fields: [assignedById], references: [id])

  @@map("vendor_tickets")
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  ticketId  String?
  action    String
  entity    String
  entityId  String
  oldValues Json?
  newValues Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  ticket    Ticket?  @relation(fields: [ticketId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])

  @@map("audit_logs")
}

model LoginAttempt {
  id            String   @id @default(cuid())
  email         String
  ipAddress     String?
  userAgent     String?
  success       Boolean
  attemptedAt   DateTime @default(now())
  lockTriggered Boolean  @default(false)

  @@map("login_attempts")
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  userId    String
  email     String
  expiresAt DateTime
  usedAt    DateTime?
  ipAddress String?
  userAgent String?
  createdAt DateTime  @default(now())

  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

model SupportGroup {
  id            String         @id @default(cuid())
  name          String         @unique
  description   String?
  code          String         @unique
  isActive      Boolean        @default(true)
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  legacyTickets LegacyTicket[]
  services      Service[]
  tickets       Ticket[]
  users         User[]

  @@map("support_groups")
}

model KnowledgeArticle {
  id             String                @id @default(cuid())
  title          String
  content        String
  categoryId     String?
  tags           String[]
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  authorId       String
  expiresAt      DateTime?
  helpful        Int                   @default(0)
  isActive       Boolean               @default(true)
  itemId         String?
  notHelpful     Int                   @default(0)
  publishedAt    DateTime?
  slug           String                @unique
  status         KnowledgeStatus       @default(DRAFT)
  subcategoryId  String?
  summary        String?
  views          Int                   @default(0)
  author         User                  @relation(fields: [authorId], references: [id])
  category       Category?             @relation(fields: [categoryId], references: [id])
  item           Item?                 @relation(fields: [itemId], references: [id])
  subcategory    Subcategory?          @relation(fields: [subcategoryId], references: [id])
  attachments    KnowledgeAttachment[]
  comments       KnowledgeComment[]
  feedback       KnowledgeFeedback[]
  versions       KnowledgeVersion[]
  relatedTickets TicketKnowledge[]

  // New relations
  collaborators  KnowledgeCollaborator[]
  serviceLinks   KnowledgeServiceLink[]
  activities     KnowledgeActivity[]

  @@index([status, isActive])
  @@index([categoryId, subcategoryId, itemId])
  @@index([publishedAt])
  @@index([views])
  @@map("knowledge_articles")
}

model TaskTemplate {
  id          String             @id @default(cuid())
  serviceId   String
  name        String
  description String?
  isActive    Boolean            @default(true)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  items       TaskTemplateItem[]
  service     Service            @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@map("task_templates")
}

model TaskTemplateItem {
  id               String       @id @default(cuid())
  taskTemplateId   String
  title            String
  description      String?
  estimatedMinutes Int?         @default(30)
  order            Int          @default(0)
  isRequired       Boolean      @default(true)
  knowledgeBaseUrl String?
  isActive         Boolean      @default(true)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  taskTemplate     TaskTemplate @relation(fields: [taskTemplateId], references: [id], onDelete: Cascade)
  ticketTasks      TicketTask[]

  @@map("task_template_items")
}

model TicketTask {
  id                 String           @id @default(cuid())
  ticketId           String
  taskTemplateItemId String
  status             TaskStatus       @default(PENDING)
  startedAt          DateTime?
  completedAt        DateTime?
  actualMinutes      Int?
  notes              String?
  completedById      String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  completedBy        User?            @relation(fields: [completedById], references: [id])
  taskTemplateItem   TaskTemplateItem @relation(fields: [taskTemplateItemId], references: [id])
  ticket             Ticket           @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, taskTemplateItemId])
  @@map("ticket_tasks")
}

model NetworkMonitoringLog {
  id              String         @id @default(cuid())
  entityType      String
  entityId        String
  ipAddress       String
  status          NetworkStatus
  responseTimeMs  Int?
  packetLoss      Float?
  errorMessage    String?
  checkedAt       DateTime       @default(now())
  previousStatus  NetworkStatus?
  statusChangedAt DateTime?
  downSince       DateTime?
  uptimeSeconds   Int?
  downtimeSeconds Int?

  @@unique([entityType, entityId])
  @@map("network_monitoring_logs")
}

model NetworkStatusHistory {
  id             String         @id @default(cuid())
  entityType     String
  entityId       String
  ipAddress      String
  status         NetworkStatus
  previousStatus NetworkStatus?
  responseTimeMs Int?
  packetLoss     Float?
  errorMessage   String?
  duration       Int?
  startedAt      DateTime
  endedAt        DateTime?
  createdAt      DateTime       @default(now())

  @@index([entityType, entityId, startedAt])
  @@index([status, startedAt])
  @@map("network_status_history")
}

model NetworkIncident {
  id                  String              @id @default(cuid())
  branchId            String?
  atmId               String?
  type                NetworkIncidentType
  severity            IncidentSeverity
  description         String
  status              IncidentStatus      @default(OPEN)
  ticketId            String?
  detectedAt          DateTime            @default(now())
  resolvedAt          DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  externalReferenceId String?
  metrics             Json?
  atm                 ATM?                @relation(fields: [atmId], references: [id], onDelete: Cascade)
  branch              Branch?             @relation(fields: [branchId], references: [id])
  ticket              Ticket?             @relation(fields: [ticketId], references: [id])

  @@map("network_incidents")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  user      User             @relation(fields: [userId], references: [id])

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

model ApiKey {
  id              String           @id @default(cuid())
  name            String
  key             String           @unique
  hashedKey       String           @unique
  description     String?
  permissions     Json?
  isActive        Boolean          @default(true)
  expiresAt       DateTime?
  lastUsedAt      DateTime?
  usageCount      Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  createdById     String
  linkedUserId    String?
  createdBy       User             @relation("ApiKeyCreatedBy", fields: [createdById], references: [id])
  linkedUser      User?            @relation("ApiKeyLinkedUser", fields: [linkedUserId], references: [id])
  omnichannelLogs OmnichannelLog[]

  @@index([key])
  @@index([hashedKey])
  @@index([isActive])
  @@index([linkedUserId])
}

model NetworkPingResult {
  id                 String        @id @default(cuid())
  entityType         String
  entityId           String
  branchId           String?
  atmId              String?
  ipAddress          String
  ipType             String        @default("PRIMARY")
  networkMedia       NetworkMedia?
  networkVendor      String?
  status             NetworkStatus
  responseTimeMs     Int?
  packetLoss         Float?        @default(0)
  minRtt             Float?
  maxRtt             Float?
  avgRtt             Float?
  mdev               Float?
  packetsTransmitted Int?
  packetsReceived    Int?
  errorMessage       String?
  checkedAt          DateTime      @default(now())
  atm                ATM?          @relation("ATMPingResults", fields: [atmId], references: [id], onDelete: Cascade)
  branch             Branch?       @relation("BranchPingResults", fields: [branchId], references: [id])

  @@index([entityType, entityId])
  @@index([checkedAt])
  @@index([status])
  @@map("network_ping_results")
}

model ServiceUsage {
  id        String   @id @default(cuid())
  serviceId String
  userId    String
  ticketId  String
  branchId  String?
  usedAt    DateTime @default(now())
  branch    Branch?  @relation(fields: [branchId], references: [id])
  service   Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([serviceId, usedAt])
  @@index([userId, serviceId])
  @@index([branchId, serviceId])
  @@index([usedAt])
  @@map("service_usage")
}

model UserFavoriteService {
  id         String   @id @default(cuid())
  userId     String
  serviceId  String
  lastUsedAt DateTime @updatedAt
  isPinned   Boolean  @default(false)
  order      Int      @default(0)
  createdAt  DateTime @default(now())
  service    Service  @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, serviceId])
  @@index([userId, lastUsedAt])
  @@index([userId, isPinned, order])
  @@map("user_favorite_services")
}

model UserFavoriteCategory {
  id         String          @id @default(cuid())
  userId     String
  categoryId String
  order      Int             @default(0)
  createdAt  DateTime        @default(now())
  category   ServiceCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, categoryId])
  @@index([userId, order])
  @@map("user_favorite_categories")
}

model KnowledgeVersion {
  id          String           @id @default(cuid())
  articleId   String
  version     Int
  title       String
  content     String
  summary     String?
  changeNotes String?
  authorId    String
  createdAt   DateTime         @default(now())
  article     KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  author      User             @relation(fields: [authorId], references: [id])

  @@unique([articleId, version])
  @@index([articleId, createdAt])
  @@map("knowledge_versions")
}

model KnowledgeAttachment {
  id           String           @id @default(cuid())
  articleId    String
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  version      Int              @default(1)
  uploadedBy   String
  createdAt    DateTime         @default(now())
  article      KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  uploader     User             @relation(fields: [uploadedBy], references: [id])

  @@index([articleId])
  @@map("knowledge_attachments")
}

model KnowledgeComment {
  id         String             @id @default(cuid())
  articleId  String
  userId     String
  content    String
  parentId   String?
  isResolved Boolean            @default(false)
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  article    KnowledgeArticle   @relation(fields: [articleId], references: [id], onDelete: Cascade)
  parent     KnowledgeComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies    KnowledgeComment[] @relation("CommentReplies")
  user       User               @relation(fields: [userId], references: [id])

  // File attachments
  attachments KnowledgeCommentAttachment[]

  @@index([articleId, parentId])
  @@index([userId])
  @@map("knowledge_comments")
}

model TicketKnowledge {
  id        String           @id @default(cuid())
  ticketId  String
  articleId String
  linkedBy  String
  linkedAt  DateTime         @default(now())
  article   KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [linkedBy], references: [id])
  ticket    Ticket           @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, articleId])
  @@index([ticketId])
  @@index([articleId])
  @@map("ticket_knowledge")
}

model KnowledgeFeedback {
  id        String           @id @default(cuid())
  articleId String
  userId    String
  isHelpful Boolean
  comment   String?
  createdAt DateTime         @default(now())
  article   KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id])

  @@unique([articleId, userId])
  @@index([articleId, isHelpful])
  @@map("knowledge_feedback")
}

model CustomReport {
  id            String            @id @default(cuid())
  title         String
  description   String?
  type          ReportType
  module        String
  configuration Json
  query         String?
  columns       Json
  filters       Json
  groupBy       String[]
  orderBy       Json
  chartConfig   Json?
  createdBy     String
  isPublic      Boolean           @default(false)
  category      String?
  tags          String[]
  lastRunAt     DateTime?
  runCount      Int               @default(0)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  creator       User              @relation("ReportCreator", fields: [createdBy], references: [id])
  executions    ReportExecution[]
  favorites     ReportFavorite[]
  schedules     ReportSchedule[]

  @@index([createdBy])
  @@index([type])
  @@index([module])
  @@map("custom_reports")
}

model ReportSchedule {
  id           String            @id @default(cuid())
  reportId     String
  frequency    ScheduleFrequency
  scheduleTime String
  nextRunAt    DateTime
  lastRunAt    DateTime?
  format       ExportFormat
  recipients   String[]
  emailSubject String?
  emailBody    String?
  isActive     Boolean           @default(true)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  report       CustomReport      @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
  @@index([nextRunAt])
  @@map("report_schedules")
}

model ReportExecution {
  id            String          @id @default(cuid())
  reportId      String
  executedBy    String?
  status        ExecutionStatus
  resultCount   Int?
  executionTime Int?
  error         String?
  resultPath    String?
  createdAt     DateTime        @default(now())
  executor      User?           @relation("ReportExecutor", fields: [executedBy], references: [id])
  report        CustomReport    @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@index([reportId])
  @@index([executedBy])
  @@map("report_executions")
}

model ReportFavorite {
  id        String       @id @default(cuid())
  reportId  String
  userId    String
  createdAt DateTime     @default(now())
  report    CustomReport @relation(fields: [reportId], references: [id], onDelete: Cascade)
  user      User         @relation("ReportFavorites", fields: [userId], references: [id])

  @@unique([reportId, userId])
  @@map("report_favorites")
}

model ReportTemplate {
  id              String   @id @default(cuid())
  name            String
  description     String?
  serviceId       String?
  baseQuery       String
  availableFields Json
  defaultFilters  Json?
  category        String
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  service         Service? @relation(fields: [serviceId], references: [id])

  @@index([serviceId])
  @@map("report_templates")
}

model ATMClaimVerification {
  id                  String                      @id @default(cuid())
  ticketId            String                      @unique
  journalChecked      Boolean                     @default(false)
  journalFindings     String?
  journalAttachments  Json?
  ejTransactionFound  Boolean?
  ejReferenceNumber   String?
  amountMatches       Boolean?
  cashOpening         Decimal?                    @db.Decimal(15, 2)
  cashDispensed       Decimal?                    @db.Decimal(15, 2)
  cashRemaining       Decimal?                    @db.Decimal(15, 2)
  cashVariance        Decimal?                    @db.Decimal(15, 2)
  cctvReviewed        Boolean                     @default(false)
  cctvFindings        String?
  cctvEvidenceUrl     String?
  cctvRequestedAt     DateTime?
  debitSuccessful     Boolean?
  reversalCompleted   Boolean?
  coreSystemCheckedAt DateTime?
  verifiedById        String?
  verifiedAt          DateTime?
  recommendation      VerificationRecommendation?
  recommendationNotes String?
  attachments         Json?
  createdAt           DateTime                    @default(now())
  updatedAt           DateTime                    @updatedAt
  ticket              Ticket                      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  verifiedBy          User?                       @relation(fields: [verifiedById], references: [id])

  @@map("atm_claim_verifications")
}

model BranchAssignment {
  id           String           @id @default(cuid())
  ticketId     String
  branchId     String
  assignedToId String
  assignedById String
  taskType     BranchTaskType
  dueTime      DateTime
  priority     TicketPriority   @default(MEDIUM)
  status       AssignmentStatus @default(ASSIGNED)
  startedAt    DateTime?
  completedAt  DateTime?
  instructions String?
  notes        String?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  assignedBy   User             @relation("AssignedByBranchTasks", fields: [assignedById], references: [id])
  assignedTo   User             @relation("AssignedBranchTasks", fields: [assignedToId], references: [id])
  branch       Branch           @relation(fields: [branchId], references: [id])
  ticket       Ticket           @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([branchId, status])
  @@index([assignedToId, status])
  @@map("branch_assignments")
}

model BranchCommunication {
  id           String            @id @default(cuid())
  ticketId     String
  fromBranchId String
  toBranchId   String?
  userId       String
  message      String
  messageType  CommunicationType @default(INFO)
  attachments  Json?
  readBy       Json?
  createdAt    DateTime          @default(now())
  fromBranch   Branch            @relation("SentCommunications", fields: [fromBranchId], references: [id])
  ticket       Ticket            @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  toBranch     Branch?           @relation("ReceivedCommunications", fields: [toBranchId], references: [id])
  user         User              @relation(fields: [userId], references: [id])

  @@index([ticketId, createdAt])
  @@map("branch_communications")
}

model LegacyTicket {
  id                  String                   @id @default(cuid())
  ticketNumber        String                   @unique
  title               String
  description         String
  category            TicketCategory           @default(INCIDENT)
  serviceId           String
  priority            TicketPriority           @default(MEDIUM)
  status              TicketStatus             @default(OPEN)
  createdById         String
  assignedToId        String?
  branchId            String?
  supportGroupId      String?
  isConfidential      Boolean                  @default(false)
  issueClassification IssueClassification?
  resolutionNotes     String?
  originalTicketId    String
  originalSystem      String
  originalData        Json
  importedAt          DateTime                 @default(now())
  importBatchId       String
  mappedToTicketId    String?                  @unique
  isConverted         Boolean                  @default(false)
  convertedAt         DateTime?
  convertedById       String?
  originalCreatedAt   DateTime
  originalUpdatedAt   DateTime?
  originalResolvedAt  DateTime?
  originalClosedAt    DateTime?
  createdAt           DateTime                 @default(now())
  updatedAt           DateTime                 @updatedAt
  attachments         LegacyTicketAttachment[]
  comments            LegacyTicketComment[]
  assignedTo          User?                    @relation("LegacyTicketAssignee", fields: [assignedToId], references: [id])
  branch              Branch?                  @relation(fields: [branchId], references: [id])
  convertedBy         User?                    @relation("LegacyTicketConverter", fields: [convertedById], references: [id])
  createdBy           User                     @relation("LegacyTicketCreator", fields: [createdById], references: [id])
  migrationBatch      MigrationBatch           @relation(fields: [importBatchId], references: [id])
  mappedToTicket      Ticket?                  @relation("LegacyTicketMapping", fields: [mappedToTicketId], references: [id])
  service             Service                  @relation(fields: [serviceId], references: [id])
  supportGroup        SupportGroup?            @relation(fields: [supportGroupId], references: [id])

  @@index([originalSystem, originalTicketId])
  @@index([importBatchId])
  @@index([isConverted])
  @@map("legacy_tickets")
}

model LegacyTicketComment {
  id                String       @id @default(cuid())
  legacyTicketId    String
  content           String
  isInternal        Boolean      @default(false)
  originalAuthor    String?
  originalData      Json?
  createdAt         DateTime     @default(now())
  originalCreatedAt DateTime
  legacyTicket      LegacyTicket @relation(fields: [legacyTicketId], references: [id], onDelete: Cascade)

  @@map("legacy_ticket_comments")
}

model LegacyTicketAttachment {
  id             String       @id @default(cuid())
  legacyTicketId String
  filename       String
  originalName   String
  mimeType       String
  size           Int
  originalUrl    String?
  downloadUrl    String?
  isDownloaded   Boolean      @default(false)
  originalData   Json?
  createdAt      DateTime     @default(now())
  legacyTicket   LegacyTicket @relation(fields: [legacyTicketId], references: [id], onDelete: Cascade)

  @@map("legacy_ticket_attachments")
}

model MigrationBatch {
  id            String          @id @default(cuid())
  source        String
  status        MigrationStatus @default(PENDING)
  totalCount    Int             @default(0)
  importedCount Int             @default(0)
  errorCount    Int             @default(0)
  startedAt     DateTime?
  completedAt   DateTime?
  metadata      Json?
  errorLog      Json?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  legacyTickets LegacyTicket[]
  tickets       Ticket[]

  @@map("migration_batches")
}

enum NetworkMedia {
  VSAT
  M2M
  FO
}

enum UserRole {
  USER
  TECHNICIAN
  MANAGER
  MANAGER_IT      // IT Manager with shift management access
  ADMIN
  SECURITY_ANALYST
}

enum TicketCategory {
  INCIDENT
  SERVICE_REQUEST
  CHANGE_REQUEST
  EVENT_REQUEST
}

enum TicketStatus {
  OPEN
  PENDING_APPROVAL
  APPROVED
  REJECTED
  IN_PROGRESS
  PENDING_VENDOR
  RESOLVED
  CLOSED
  CANCELLED
  PENDING
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  EMERGENCY
}

enum IssueClassification {
  HUMAN_ERROR
  SYSTEM_ERROR
  HARDWARE_FAILURE
  NETWORK_ISSUE
  SECURITY_INCIDENT
  DATA_ISSUE
  PROCESS_GAP
  EXTERNAL_FACTOR
}

enum FieldType {
  TEXT
  TEXTAREA
  EMAIL
  PHONE
  NUMBER
  DATE
  DATETIME
  SELECT
  MULTISELECT
  RADIO
  CHECKBOX
  FILE
  URL
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ATMStatus {
  ONLINE
  OFFLINE
  WARNING
  ERROR
  MAINTENANCE
}

enum IncidentType {
  NETWORK_DOWN
  HARDWARE_FAILURE
  SOFTWARE_ERROR
  MAINTENANCE
  SECURITY_BREACH
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum VendorStatus {
  PENDING
  SUBMITTED
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

enum NetworkStatus {
  ONLINE
  OFFLINE
  SLOW
  TIMEOUT
  ERROR
}

enum NetworkIncidentType {
  COMMUNICATION_OFFLINE
  SLOW_CONNECTION
  PACKET_LOSS
  HIGH_LATENCY
  DNS_ISSUE
  NETWORK_CONGESTION
}

enum NotificationType {
  TICKET_CREATED
  TICKET_ASSIGNED
  TICKET_UPDATED
  TICKET_RESOLVED
  TICKET_CLOSED
  TICKET_COMMENT
  TICKET_APPROVED
  TICKET_REJECTED
  TICKET_ESCALATED
  SYSTEM_ALERT
  MENTION
}

enum KnowledgeStatus {
  DRAFT
  UNDER_REVIEW
  PUBLISHED
  ARCHIVED
  EXPIRED
}

enum ReportType {
  TABULAR
  MATRIX
  METRICS
  QUERY
}

enum ScheduleFrequency {
  ONCE
  DAILY
  WEEKLY
  MONTHLY
}

enum ExportFormat {
  PDF
  EXCEL
  CSV
  HTML
}

enum ExecutionStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum VerificationRecommendation {
  APPROVE
  REJECT
  ESCALATE
  NEED_MORE_INFO
}

enum BranchTaskType {
  VERIFY_CLAIM
  REVIEW_DOCUMENTS
  PROCESS_REFUND
  CONTACT_CUSTOMER
  CHECK_CCTV
  RECONCILE_CASH
}

enum AssignmentStatus {
  ASSIGNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  OVERDUE
}

enum CommunicationType {
  INFO
  URGENT
  REQUEST
  RESPONSE
  ESCALATION
}

enum MigrationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  CANCELLED
}

// PC Asset Management Enums
enum OSLicenseType {
  OEM
  FPP
  OLP
  VOLUME
  OPEN_SOURCE
  TRIAL
  OTHER
}

enum OfficeLicenseType {
  OEM
  FPP
  OLP
  VOLUME
  SUBSCRIPTION
  OPEN_SOURCE
  OTHER
}

enum OfficeProductType {
  OFFICE_365
  OFFICE_2021_LTSC
  OFFICE_2019
  OFFICE_2016
  LIBRE_OFFICE
  OPEN_OFFICE
  WPS_OFFICE
  OTHER
}

enum PCServiceType {
  HARDENING
  MAINTENANCE
  REPAIR
  UPGRADE
  INSTALLATION
  AUDIT
  DECOMMISSION
}

enum HardeningCategory {
  USER_ACCOUNTS
  NETWORK_SECURITY
  SYSTEM_UPDATES
  FIREWALL
  ANTIVIRUS
  ACCESS_CONTROL
  DATA_ENCRYPTION
  AUDIT_LOGGING
  APPLICATION_CONTROL
  OTHER
}

// PC Asset Management Models
model PCAsset {
  id                    String            @id @default(cuid())
  pcName                String            @unique
  brand                 String
  model                 String?
  serialNumber          String?
  
  // Hardware specifications
  processor             String
  ram                   String            // e.g., "16GB DDR4"
  storageDevices        Json              // Array of {type: "SSD/HDD", size: "512GB", brand: "Samsung"}
  macAddress            String?
  ipAddress             String?
  
  // Location and assignment
  branchId              String
  assignedToId          String?
  
  // Purchase information
  purchaseDate          DateTime?
  purchaseOrderNumber   String?
  warrantyExpiry        DateTime?
  assetTag              String?           @unique
  
  // Operating System
  operatingSystemId     String?           // Reference to OperatingSystem
  osLicenseType         OSLicenseType?    // Keep for license type tracking
  osSerialNumber        String?           // Keep for serial number if needed
  
  // Office Suite  
  officeProductId       String?           // Reference to OfficeProduct
  officeLicenseType     OfficeLicenseType? // Keep for license type tracking
  officeSerialNumber    String?           // Keep for serial number if needed
  
  // Security
  antivirusName         String?
  antivirusVersion      String?
  antivirusLicenseExpiry DateTime?
  lastHardeningDate     DateTime?
  hardeningCompliant    Boolean           @default(false)
  
  // Metadata
  isActive              Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdById           String
  lastAuditDate         DateTime?
  notes                 String?
  
  // Relations
  branch                Branch            @relation(fields: [branchId], references: [id])
  assignedTo            User?             @relation("AssignedPCAssets", fields: [assignedToId], references: [id])
  createdBy             User              @relation("CreatedPCAssets", fields: [createdById], references: [id])
  operatingSystem       OperatingSystem?  @relation(fields: [operatingSystemId], references: [id])
  officeProduct         OfficeProduct?    @relation(fields: [officeProductId], references: [id])
  serviceLogs           PCServiceLog[]
  hardeningChecklists   HardeningChecklist[]
  osLicenses            OSLicense[]
  officeLicenses        OfficeLicense[]
  antivirusLicenses     AntivirusLicense[]
  
  @@index([branchId])
  @@index([assignedToId])
  @@index([isActive])
  @@index([operatingSystemId])
  @@index([officeProductId])
  @@index([antivirusLicenseExpiry])
  @@index([warrantyExpiry])
  @@map("pc_assets")
}

model PCServiceLog {
  id                    String            @id @default(cuid())
  pcAssetId             String
  ticketId              String?
  serviceType           PCServiceType
  performedById         String
  performedAt           DateTime          @default(now())
  
  // Service details
  description           String
  findings              String?
  recommendations       String?
  beforeStatus          Json?             // Snapshot of PC status before service
  afterStatus           Json?             // Snapshot of PC status after service
  attachments           Json?             // Array of file paths/URLs
  
  // Relations
  pcAsset               PCAsset           @relation(fields: [pcAssetId], references: [id], onDelete: Cascade)
  ticket                Ticket?           @relation(fields: [ticketId], references: [id])
  performedBy           User              @relation(fields: [performedById], references: [id])
  hardeningChecklist    HardeningChecklist?
  
  @@index([pcAssetId, performedAt])
  @@index([ticketId])
  @@index([serviceType])
  @@map("pc_service_logs")
}

model HardeningTemplate {
  id                    String            @id @default(cuid())
  name                  String            @unique
  description           String?
  osType                String            // e.g., "Windows 11", "Ubuntu 22.04"
  version               String            @default("1.0")
  isActive              Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Relations
  checklistItems        HardeningChecklistItem[]
  hardeningChecklists   HardeningChecklist[]
  
  @@map("hardening_templates")
}

model HardeningChecklistItem {
  id                    String            @id @default(cuid())
  templateId            String
  category              HardeningCategory
  itemCode              String            // e.g., "UA-001" for User Account item 001
  title                 String
  description           String?
  isRequired            Boolean           @default(true)
  order                 Int               @default(0)
  verificationSteps     String?           // How to verify this item is compliant
  remediationSteps      String?           // How to fix if non-compliant
  
  // Relations
  template              HardeningTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  checklistResults      HardeningChecklistResult[]
  
  @@unique([templateId, itemCode])
  @@index([templateId, category])
  @@map("hardening_checklist_items")
}

model HardeningChecklist {
  id                    String            @id @default(cuid())
  pcAssetId             String
  templateId            String
  serviceLogId          String?           @unique
  performedById         String
  startedAt             DateTime          @default(now())
  completedAt           DateTime?
  complianceScore       Float?            // Percentage of compliant items
  status                String            @default("IN_PROGRESS") // IN_PROGRESS, COMPLETED, CANCELLED
  notes                 String?
  
  // Relations
  pcAsset               PCAsset           @relation(fields: [pcAssetId], references: [id], onDelete: Cascade)
  template              HardeningTemplate @relation(fields: [templateId], references: [id])
  serviceLog            PCServiceLog?     @relation(fields: [serviceLogId], references: [id])
  performedBy           User              @relation(fields: [performedById], references: [id])
  checklistResults      HardeningChecklistResult[]
  
  @@index([pcAssetId, startedAt])
  @@index([status])
  @@map("hardening_checklists")
}

model HardeningChecklistResult {
  id                    String            @id @default(cuid())
  checklistId           String
  checklistItemId       String
  isCompliant           Boolean
  notes                 String?
  evidence              Json?             // Screenshots or other evidence
  checkedAt             DateTime          @default(now())
  
  // Relations
  checklist             HardeningChecklist @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  checklistItem         HardeningChecklistItem @relation(fields: [checklistItemId], references: [id])
  
  @@unique([checklistId, checklistItemId])
  @@map("hardening_checklist_results")
}

// ============================================
// OS License Management
// ============================================

model OSLicense {
  id                    String            @id @default(cuid())
  name                  String            // License name/description
  osName                String            // e.g., Windows 11 Pro, Windows Server 2022
  osVersion             String?           // e.g., 22H2, 21H1
  licenseType           OSLicenseType     // OEM, FPP, OLP, etc.
  licenseKey            String?           @unique // Product key
  purchaseDate          DateTime?
  expiryDate            DateTime?
  cost                  Float?
  vendor                String?           // Where purchased from
  invoiceNumber         String?
  maxActivations        Int               @default(1)
  currentActivations    Int               @default(0)
  isActive              Boolean           @default(true)
  notes                 String?           @db.Text
  
  // Assignment tracking
  assignedToPC          String?           // Can be assigned to specific PC
  assignedToBranch      String?           // Or assigned to branch
  assignedToUser        String?           // Or assigned to user
  
  // Relations
  pcAsset               PCAsset?          @relation(fields: [assignedToPC], references: [id], onDelete: SetNull)
  branch                Branch?           @relation(fields: [assignedToBranch], references: [id], onDelete: SetNull)
  user                  User?             @relation("OSLicenseAssignedUser", fields: [assignedToUser], references: [id], onDelete: SetNull)
  
  // Audit fields
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdBy             String?
  createdByUser         User?             @relation("OSLicenseCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)
  
  @@index([licenseType, isActive])
  @@index([osName])
  @@index([assignedToPC])
  @@index([assignedToBranch])
  @@map("os_licenses")
}

// ============================================
// Office License Management
// ============================================

model OfficeLicense {
  id                    String            @id @default(cuid())
  name                  String            // License name/description
  productName           String            // e.g., Office 365, Office 2021 LTSC
  productType           OfficeProductType // OFFICE_365, OFFICE_2021_LTSC, etc.
  licenseType           OfficeLicenseType // SUBSCRIPTION, PERPETUAL, etc.
  licenseKey            String?           @unique // Product key or subscription ID
  subscriptionId        String?           // For subscription-based licenses
  purchaseDate          DateTime?
  expiryDate            DateTime?
  renewalDate           DateTime?         // For subscriptions
  cost                  Float?
  costPeriod            String?           // Monthly, Yearly, One-time
  vendor                String?           // Where purchased from
  invoiceNumber         String?
  maxUsers              Int               @default(1)
  currentUsers          Int               @default(0)
  isActive              Boolean           @default(true)
  autoRenew             Boolean           @default(false)
  notes                 String?           @db.Text
  
  // Assignment tracking
  assignedToPC          String?           // Can be assigned to specific PC
  assignedToBranch      String?           // Or assigned to branch
  assignedToUser        String?           // Or assigned to user
  
  // Relations
  pcAsset               PCAsset?          @relation(fields: [assignedToPC], references: [id], onDelete: SetNull)
  branch                Branch?           @relation(fields: [assignedToBranch], references: [id], onDelete: SetNull)
  user                  User?             @relation("OfficeLicenseAssignedUser", fields: [assignedToUser], references: [id], onDelete: SetNull)
  
  // Audit fields
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdBy             String?
  createdByUser         User?             @relation("OfficeLicenseCreatedBy", fields: [createdBy], references: [id], onDelete: SetNull)
  
  @@index([productType, isActive])
  @@index([licenseType])
  @@index([assignedToPC])
  @@index([assignedToBranch])
  @@index([expiryDate])
  @@map("office_licenses")
}

// ============================================
// Antivirus License Management
// ============================================

model AntivirusLicense {
  id                    String            @id @default(cuid())
  name                  String            // License name/description
  productName           String            // e.g., Kaspersky, Norton, McAfee, Windows Defender
  productVersion        String?           // e.g., 2024, 21.0.1
  licenseType           String            // SUBSCRIPTION, PERPETUAL, TRIAL
  licenseKey            String?           @unique // Product key or license code
  subscriptionId        String?           // For subscription-based licenses
  purchaseDate          DateTime?
  expiryDate            DateTime?
  renewalDate           DateTime?         // For subscriptions
  cost                  Float?
  costPeriod            String?           // Monthly, Yearly, One-time
  vendor                String?           // Where purchased from
  invoiceNumber         String?
  maxDevices            Int               @default(1)
  currentDevices        Int               @default(0)
  isActive              Boolean           @default(true)
  autoRenew             Boolean           @default(false)
  notes                 String?           @db.Text
  
  // Assignment tracking
  assignedToPC          String?           // Can be assigned to specific PC
  assignedToBranch      String?           // Or assigned to branch
  assignedToUser        String?           // Or assigned to user
  
  // Relations
  pcAsset               PCAsset?          @relation(fields: [assignedToPC], references: [id], onDelete: SetNull)
  branch                Branch?           @relation(fields: [assignedToBranch], references: [id], onDelete: SetNull)
  user                  User?             @relation("AntivirusLicenseAssignedUser", fields: [assignedToUser], references: [id], onDelete: SetNull)
  
  // Timestamps
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  // Indexes
  @@index([expiryDate])
  @@index([assignedToPC])
  @@index([assignedToBranch])
  @@index([isActive])
  
  @@map("antivirus_licenses")
}

// ============================================
// OS and Office Type Management
// ============================================

model OperatingSystem {
  id                    String            @id @default(cuid())
  name                  String            // e.g., "Windows 10 Pro", "Windows 11 Enterprise"
  version               String?           // e.g., "22H2", "21H1"
  type                  OSType            // WINDOWS, LINUX, MACOS, OTHER
  architecture          String?           // e.g., "x64", "x86", "ARM"
  edition               String?           // e.g., "Pro", "Enterprise", "Home"
  isActive              Boolean           @default(true)
  description           String?           @db.Text
  sortOrder             Int               @default(0)
  
  // Relations
  pcAssets              PCAsset[]
  
  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdById           String?
  createdBy             User?             @relation("OSCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  
  @@unique([name, version])
  @@index([type, isActive])
  @@index([sortOrder])
  @@map("operating_systems")
}

model OfficeProduct {
  id                    String            @id @default(cuid())
  name                  String            // e.g., "Office 365", "Office LTSC 2021"
  version               String?           // e.g., "2021", "2024", "365"
  type                  OfficeType        // MICROSOFT_365, LTSC, LIBRE_OFFICE, OPEN_OFFICE, WPS, OTHER
  edition               String?           // e.g., "Professional Plus", "Standard", "Home & Business"
  isActive              Boolean           @default(true)
  description           String?           @db.Text
  sortOrder             Int               @default(0)
  
  // Relations
  pcAssets              PCAsset[]
  
  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdById           String?
  createdBy             User?             @relation("OfficeCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  
  @@unique([name, version])
  @@index([type, isActive])
  @@index([sortOrder])
  @@map("office_products")
}

enum OSType {
  WINDOWS
  LINUX
  MACOS
  UNIX
  CHROME_OS
  OTHER
}

enum OfficeType {
  MICROSOFT_365
  OFFICE_LTSC
  LIBRE_OFFICE
  OPEN_OFFICE
  WPS_OFFICE
  GOOGLE_WORKSPACE
  OTHER
}

model DailyTaskList {
  id            String      @id @default(cuid())
  technicianId  String
  date          DateTime    @db.Date
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  technician    User        @relation(fields: [technicianId], references: [id])
  tasks         DailyTask[]

  @@unique([technicianId, date])
  @@index([technicianId, date])
  @@map("daily_task_lists")
}

model DailyTask {
  id              String         @id @default(cuid())
  taskListId      String
  ticketId        String?        // Optional link to ticket
  title           String
  description     String?
  category        DailyTaskCategory @default(OTHER)
  status          DailyTaskStatus   @default(PENDING)
  priority        TicketPriority?
  startTime       DateTime?
  endTime         DateTime?
  actualMinutes   Int?
  notes           String?        @db.Text
  order           Int            @default(0)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  taskList        DailyTaskList  @relation(fields: [taskListId], references: [id], onDelete: Cascade)
  ticket          Ticket?        @relation(fields: [ticketId], references: [id])

  @@index([taskListId])
  @@map("daily_tasks")
}

enum DailyTaskCategory {
  TICKET
  MAINTENANCE
  MEETING
  TRAINING
  DOCUMENTATION
  SUPPORT
  OTHER
}

enum DailyTaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DEFERRED
}

// Knowledge Base Collaborators
model KnowledgeCollaborator {
  id          String           @id @default(cuid())
  articleId   String
  userId      String
  role        CollaboratorRole @default(EDITOR)
  invitedBy   String
  invitedAt   DateTime         @default(now())
  acceptedAt  DateTime?

  article     KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user        User             @relation("CollaboratorUser", fields: [userId], references: [id])
  inviter     User             @relation("InvitedByUser", fields: [invitedBy], references: [id])

  @@unique([articleId, userId])
  @@index([userId])
  @@map("knowledge_collaborators")
}

enum CollaboratorRole {
  VIEWER
  EDITOR
  OWNER
}

// Knowledge Service Linking
model KnowledgeServiceLink {
  id            String           @id @default(cuid())
  articleId     String
  serviceId     String?
  categoryId    String?
  linkedBy      String
  linkedAt      DateTime         @default(now())

  article       KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  service       Service?         @relation(fields: [serviceId], references: [id])
  category      ServiceCategory? @relation(fields: [categoryId], references: [id])
  user          User             @relation("KnowledgeLinkUser", fields: [linkedBy], references: [id])

  @@unique([articleId, serviceId])
  @@unique([articleId, categoryId])
  @@index([serviceId])
  @@index([categoryId])
  @@map("knowledge_service_links")
}

// Knowledge Activity Timeline
model KnowledgeActivity {
  id          String       @id @default(cuid())
  articleId   String
  userId      String
  action      String       // created, edited, commented, linked_service, added_collaborator, etc
  details     Json?        // Store action-specific details
  metadata    Json?        // Store old/new values for edits
  createdAt   DateTime     @default(now())

  article     KnowledgeArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user        User             @relation(fields: [userId], references: [id])

  @@index([articleId, createdAt])
  @@index([userId])
  @@map("knowledge_activities")
}

// Comment Attachments
model KnowledgeCommentAttachment {
  id           String           @id @default(cuid())
  commentId    String
  filename     String
  originalName String
  mimeType     String
  size         Int
  path         String
  uploadedBy   String
  createdAt    DateTime         @default(now())

  comment      KnowledgeComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  uploader     User             @relation(fields: [uploadedBy], references: [id])

  @@index([commentId])
  @@map("knowledge_comment_attachments")
}

// Announcement System
model Announcement {
  id           String               @id @default(cuid())
  title        String
  content      String?              @db.Text
  type         AnnouncementType     @default(GENERAL)
  priority     AnnouncementPriority @default(NORMAL)
  startDate    DateTime
  endDate      DateTime
  isActive     Boolean              @default(true)
  isGlobal     Boolean              @default(true) // If true, shown to all branches
  createdBy    String
  updatedBy    String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  creator      User                 @relation("AnnouncementCreator", fields: [createdBy], references: [id])
  updater      User?                @relation("AnnouncementUpdater", fields: [updatedBy], references: [id])
  images       AnnouncementImage[]
  views        AnnouncementView[]
  branches     AnnouncementBranch[] // Branch-specific targeting

  @@index([isActive, startDate, endDate])
  @@index([createdBy])
  @@index([isGlobal])
  @@map("announcements")
}

enum AnnouncementType {
  GENERAL
  MAINTENANCE
  UPDATE
  ALERT
  PROMOTION
}

enum AnnouncementPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model AnnouncementImage {
  id             String       @id @default(cuid())
  announcementId String
  filename       String
  originalName   String
  mimeType       String
  size           Int
  path           String
  order          Int          @default(0)
  caption        String?
  createdAt      DateTime     @default(now())

  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)

  @@index([announcementId])
  @@map("announcement_images")
}

model AnnouncementView {
  id             String       @id @default(cuid())
  announcementId String
  userId         String
  viewedAt       DateTime     @default(now())

  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id])

  @@unique([announcementId, userId])
  @@index([userId])
  @@map("announcement_views")
}

// Branch-specific announcements
model AnnouncementBranch {
  id             String       @id @default(cuid())
  announcementId String
  branchId       String
  createdAt      DateTime     @default(now())

  announcement   Announcement @relation(fields: [announcementId], references: [id], onDelete: Cascade)
  branch         Branch       @relation(fields: [branchId], references: [id])

  @@unique([announcementId, branchId])
  @@index([branchId])
  @@map("announcement_branches")
}

// Omnichannel Integration Tracking
model OmnichannelLog {
  id               String    @id @default(cuid())
  apiKeyId         String
  channel          String    // WhatsApp, Email, Chat, etc.
  serviceType      String    // CLAIM, COMPLAINT, INQUIRY, etc.
  requestData      Json      // Full request payload
  responseData     Json?     // Response sent back
  ticketId         String?   // Created ticket ID if successful
  status           String    // PROCESSING, SUCCESS, FAILED, DUPLICATE, ERROR
  errorMessage     String?
  ipAddress        String?
  responseTime     Int?      // Response time in milliseconds
  createdAt        DateTime  @default(now())

  apiKey           ApiKey    @relation(fields: [apiKeyId], references: [id])
  ticket           Ticket?   @relation(fields: [ticketId], references: [id])

  @@index([apiKeyId])
  @@index([ticketId])
  @@index([status])
  @@index([createdAt])
  @@map("omnichannel_logs")
}

// Webhook Queue for async callbacks
model WebhookQueue {
  id               String    @id @default(cuid())
  url              String
  method           String    @default("POST")
  headers          Json?
  payload          Json
  status           String    @default("PENDING") // PENDING, PROCESSING, SUCCESS, FAILED
  retryCount       Int       @default(0)
  maxRetries       Int       @default(3)
  lastAttemptAt    DateTime?
  nextRetryAt      DateTime?
  responseStatus   Int?
  responseBody     String?
  error            String?
  scheduledFor     DateTime
  processedAt      DateTime?
  createdAt        DateTime  @default(now())

  @@index([status, scheduledFor])
  @@index([createdAt])
  @@map("webhook_queue")
}

// ============================================
// Shift Management System
// ============================================

// Staff member shift schedule preferences and capabilities
model StaffShiftProfile {
  id                    String            @id @default(cuid())
  userId                String            @unique
  branchId              String

  // Shift capabilities (Type 1-5)
  canWorkType1          Boolean           @default(false)  // Type 1: NIGHT_WEEKDAY (20:00-07:59) - Weekdays
  canWorkType2          Boolean           @default(false)  // Type 2: DAY_WEEKEND (08:00-19:00) - Weekends/Holidays
  canWorkType3          Boolean           @default(false)  // Type 3: NIGHT_WEEKEND (20:00-07:59) - Weekends/Holidays
  canWorkType4          Boolean           @default(false)  // Type 4: STANDBY_ONCALL - Everyday (Server only)
  canWorkType5          Boolean           @default(false)  // Type 5: STANDBY_BRANCH - Everyday (Non-server only)
  hasServerAccess       Boolean           @default(false)  // (Legacy - may be removed later)
  hasSabbathRestriction Boolean           @default(false)  // Cannot work Friday night/Saturday

  // Preference settings
  preferredShiftType    StaffShiftType?   // NIGHT, WEEKEND_DAY, MIXED
  maxNightShiftsPerMonth Int              @default(5)
  minDaysBetweenNightShifts Int           @default(3)

  // Month continuity tracking
  lastMonthEndShift     ShiftType?        // Last shift type from previous month
  carryOverOffDays      Int               @default(0) // Off days to carry to next month
  lastMonthNightCount   Int               @default(0)

  // Metadata
  isActive              Boolean           @default(true)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  user                  User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  branch                Branch            @relation(fields: [branchId], references: [id])
  shiftAssignments      ShiftAssignment[]
  leaveRequests         LeaveRequest[]
  onCallAssignments     OnCallAssignment[]
  swapRequestsInitiated ShiftSwapRequest[] @relation("SwapInitiator")
  swapRequestsReceived  ShiftSwapRequest[] @relation("SwapRecipient")

  @@index([branchId, isActive])
  @@index([canWorkType1, hasServerAccess])
  @@map("staff_shift_profiles")
}

// Monthly shift schedule for a branch
model ShiftSchedule {
  id                    String            @id @default(cuid())
  branchId              String
  month                 Int               // 1-12
  year                  Int
  status                ScheduleStatus    @default(DRAFT)
  generatedAt           DateTime?
  publishedAt           DateTime?
  publishedBy           String?

  // Generation settings
  generationRules       Json?             // Store generation parameters
  notes                 String?           @db.Text

  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdBy             String

  // Relations
  branch                Branch            @relation(fields: [branchId], references: [id])
  shiftAssignments      ShiftAssignment[]
  onCallAssignments     OnCallAssignment[]
  holidays              Holiday[]
  leaveRequests         LeaveRequest[]    @relation("ScheduleLeaves")

  @@index([branchId, month, year])
  @@index([branchId, status])
  @@index([month, year])
  @@map("shift_schedules")
}

// Individual shift assignment
model ShiftAssignment {
  id                    String            @id @default(cuid())
  scheduleId            String
  staffProfileId        String
  date                  DateTime          @db.Date
  shiftType             ShiftType

  // Shift details
  startTime             DateTime?
  endTime               DateTime?
  isAutoGenerated       Boolean           @default(true)
  isManualOverride      Boolean           @default(false)

  // Status tracking
  status                ShiftStatus       @default(SCHEDULED)
  attendanceMarked      Boolean           @default(false)
  checkInTime           DateTime?
  checkOutTime          DateTime?

  // Notes
  notes                 String?
  managerNotes          String?           @db.Text

  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  schedule              ShiftSchedule     @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  staffProfile          StaffShiftProfile @relation(fields: [staffProfileId], references: [id])
  swapRequests          ShiftSwapRequest[]

  @@unique([scheduleId, staffProfileId, date])
  @@index([scheduleId, date])
  @@index([staffProfileId, date, shiftType])
  @@index([date, shiftType])
  @@map("shift_assignments")
}

// On-call backup assignments
model OnCallAssignment {
  id                    String            @id @default(cuid())
  scheduleId            String
  staffProfileId        String
  date                  DateTime          @db.Date

  // On-call details
  reason                String?           // Why on-call needed (e.g., "Weekend day shift - no server access")
  isPrimary             Boolean           @default(true)

  // Status
  wasActivated          Boolean           @default(false)
  activatedAt           DateTime?
  activationNotes       String?

  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  schedule              ShiftSchedule     @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  staffProfile          StaffShiftProfile @relation(fields: [staffProfileId], references: [id])

  @@index([scheduleId, date])
  @@index([staffProfileId, date])
  @@map("on_call_assignments")
}

// Leave and absence requests
model LeaveRequest {
  id                    String            @id @default(cuid())
  staffProfileId        String
  leaveType             LeaveType
  scheduleId            String?           // Link to schedule for planning purposes

  // Date range
  startDate             DateTime          @db.Date
  endDate               DateTime          @db.Date
  totalDays             Int

  // Request details
  reason                String?           @db.Text
  contactNumber         String?
  emergencyContact      String?

  // Approval workflow
  status                LeaveStatus       @default(PENDING)
  approvedBy            String?
  approvedAt            DateTime?
  rejectedBy            String?
  rejectedAt            DateTime?
  rejectionReason       String?

  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  staffProfile          StaffShiftProfile @relation(fields: [staffProfileId], references: [id])
  schedule              ShiftSchedule?    @relation("ScheduleLeaves", fields: [scheduleId], references: [id])

  @@index([staffProfileId, status])
  @@index([startDate, endDate])
  @@index([scheduleId])
  @@map("leave_requests")
}

// Branch/company holidays
model Holiday {
  id                    String            @id @default(cuid())
  scheduleId            String?           // Optional link to specific schedule
  name                  String
  date                  DateTime          @db.Date
  isRecurring           Boolean           @default(false)
  holidayType           HolidayType       @default(PUBLIC)

  // Shift implications
  affectsNightShift     Boolean           @default(true)
  affectsWeekendShift   Boolean           @default(true)
  requiresMinimalStaff  Boolean           @default(false)
  minimalStaffCount     Int?

  // Metadata
  notes                 String?
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  // Relations
  schedule              ShiftSchedule?    @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  @@index([date])
  @@index([scheduleId, date])
  @@map("holidays")
}

// Shift swap requests between staff
model ShiftSwapRequest {
  id                    String            @id @default(cuid())
  initiatorProfileId    String
  recipientProfileId    String

  // Shift details
  shiftAssignmentId     String
  proposedDate          DateTime?         @db.Date // If proposing a specific date in return

  // Request details
  reason                String            @db.Text
  swapType              ShiftSwapType     @default(ONE_TO_ONE) // ONE_TO_ONE, GIVE_AWAY, TRADE

  // Workflow status
  status                SwapRequestStatus @default(PENDING_RECIPIENT)
  recipientResponse     String?
  recipientRespondedAt  DateTime?

  // Manager approval
  approvalRequired      Boolean           @default(true)
  approvedBy            String?
  approvedAt            DateTime?
  rejectedBy            String?
  rejectedAt            DateTime?
  rejectionReason       String?
  managerNotes          String?

  // Metadata
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  completedAt           DateTime?

  // Relations
  initiatorProfile      StaffShiftProfile @relation("SwapInitiator", fields: [initiatorProfileId], references: [id])
  recipientProfile      StaffShiftProfile @relation("SwapRecipient", fields: [recipientProfileId], references: [id])
  shiftAssignment       ShiftAssignment   @relation(fields: [shiftAssignmentId], references: [id])

  @@index([initiatorProfileId, status])
  @@index([recipientProfileId, status])
  @@index([shiftAssignmentId])
  @@map("shift_swap_requests")
}

// Shift templates for quick schedule generation
model ShiftTemplate {
  id                    String            @id @default(cuid())
  name                  String
  description           String?
  branchId              String?           // Null = global template

  // Template rules
  templateRules         Json              // Store generation rules, rotation patterns
  weekdayNightCount     Int               @default(1) // Staff per weekday night
  weekendDayCount       Int               @default(2) // Staff per weekend day
  weekendNightCount     Int               @default(3) // Staff per weekend night

  // Constraints
  targetNightsPerMonth  Int               @default(5)
  minGapBetweenNights   Int               @default(3)
  requireOffAfterNight  Boolean           @default(true)

  // Metadata
  isActive              Boolean           @default(true)
  isDefault             Boolean           @default(false)
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  createdBy             String

  @@index([branchId, isActive])
  @@map("shift_templates")
}

// Enums for shift management
enum StaffShiftType {
  NIGHT           // Prefers night shifts (weekday or weekend)
  DAY             // Prefers day shifts (weekend/holiday)
  STANDBY         // Prefers standby shifts (on-call or branch ops)
  MIXED           // No preference, can do any shift
}

enum ShiftType {
  // Working shifts
  NIGHT_WEEKDAY        // 20:00-07:59 (Next Day) - Weekdays only - 1 staff - Auto OFF H+1
  DAY_WEEKEND          // 08:00-19:00 (Same Day) - Weekends/Holidays only - 1 staff
  NIGHT_WEEKEND        // 20:00-07:59 (Next Day) - Weekends/Holidays only - 1 staff
  STANDBY_ONCALL       // On-call standby - Everyday - 1 staff
  STANDBY_BRANCH       // Branch operational standby - Everyday - 1 staff

  // Non-working
  OFF                  // Day off
  LEAVE                // On leave
  HOLIDAY              // Public holiday
}

enum ScheduleStatus {
  DRAFT
  GENERATED
  PUBLISHED
  ARCHIVED
}

enum ShiftStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
  SWAPPED
}

enum LeaveType {
  ANNUAL_LEAVE
  SICK_LEAVE
  EMERGENCY_LEAVE
  UNPAID_LEAVE
  MATERNITY_LEAVE
  PATERNITY_LEAVE
  COMPASSIONATE_LEAVE
  STUDY_LEAVE
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum HolidayType {
  PUBLIC
  COMPANY
  RELIGIOUS
  SPECIAL
}

enum ShiftSwapType {
  ONE_TO_ONE      // Swap shifts with specific date
  GIVE_AWAY       // Give shift away, no return needed
  TRADE           // Trade shift for a different date
}

enum SwapRequestStatus {
  PENDING_RECIPIENT   // Waiting for recipient to accept
  PENDING_MANAGER     // Waiting for manager approval
  APPROVED            // Approved and completed
  REJECTED            // Rejected by recipient or manager
  CANCELLED           // Cancelled by initiator
}
