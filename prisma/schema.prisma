// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User Management
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  password  String?
  role      UserRole @default(USER)
  branchId  String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  branch           Branch?           @relation(fields: [branchId], references: [id])
  createdTickets   Ticket[]          @relation("TicketCreator")
  assignedTickets  Ticket[]          @relation("TicketAssignee")
  approvals        TicketApproval[]
  comments         TicketComment[]
  sessions         Session[]
  accounts         Account[]
  auditLogs        AuditLog[]
  completedTasks   TicketTask[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// Branch Management
model Branch {
  id        String   @id @default(cuid())
  name      String
  code      String   @unique
  address   String?
  city      String?
  province  String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  users   User[]
  tickets Ticket[]
  atms    ATM[]

  @@map("branches")
}

// Service Catalog
model ServiceCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  parentId    String?
  level       Int      @default(1) // 1=Category, 2=Subcategory, 3=Item
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  parent   ServiceCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children ServiceCategory[] @relation("CategoryHierarchy")
  services Service[]

  @@map("service_categories")
}

model Service {
  id                String        @id @default(cuid())
  name              String
  description       String
  helpText          String?
  categoryId        String        // Legacy - will be deprecated
  subcategoryId     String?
  itemId            String?
  supportGroup      SupportGroup  @default(IT_HELPDESK)
  priority          TicketPriority @default(MEDIUM)
  estimatedHours    Int?          @default(4)
  slaHours          Int           @default(24)
  isActive          Boolean       @default(true)
  requiresApproval  Boolean       @default(true)
  isConfidential    Boolean       @default(false)
  isKasdaService    Boolean       @default(false)
  
  // Default values for ticket creation
  defaultTitle      String?       // Auto-populate ticket title
  defaultItilCategory TicketCategory? @default(INCIDENT)
  defaultIssueClassification IssueClassification?
  
  // 3-Tier Category Relations
  tier1CategoryId    String?      // Level 1: Category
  tier2SubcategoryId String?      // Level 2: Subcategory
  tier3ItemId        String?      // Level 3: Item
  
  // SLA Configuration
  responseHours     Int?          @default(4)
  resolutionHours   Int?          @default(24)
  escalationHours   Int?          @default(48)
  businessHoursOnly Boolean       @default(true)
  
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  // Relations
  category       ServiceCategory @relation(fields: [categoryId], references: [id])
  tier1Category  Category?       @relation(fields: [tier1CategoryId], references: [id])
  tier2Subcategory Subcategory?  @relation(fields: [tier2SubcategoryId], references: [id])
  tier3Item      Item?           @relation(fields: [tier3ItemId], references: [id])
  fields         ServiceField[]
  tickets        Ticket[]
  slaTemplate    SLATemplate?
  taskTemplates  TaskTemplate[]

  @@map("services")
}

model ServiceField {
  id            String          @id @default(cuid())
  serviceId     String
  name          String
  label         String
  type          FieldType
  isRequired    Boolean         @default(false)
  isUserVisible Boolean         @default(true) // false = technician-only
  placeholder   String?
  helpText      String?
  defaultValue  String?
  options       Json?           // For select, radio, checkbox fields
  validation    Json?           // Validation rules
  order         Int             @default(0)
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  // Relations
  service      Service            @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  fieldValues  TicketFieldValue[]

  @@map("service_fields")
}

// Ticket Management
model Ticket {
  id               String           @id @default(cuid())
  ticketNumber     String           @unique
  title            String
  description      String
  category         TicketCategory   @default(INCIDENT)
  serviceId        String
  categoryId       String?          // 3-tier: Level 1 Category
  subcategoryId    String?          // 3-tier: Level 2 Subcategory  
  itemId           String?          // 3-tier: Level 3 Item
  priority         TicketPriority   @default(MEDIUM)
  status           TicketStatus     @default(OPEN)
  createdById      String
  assignedToId     String?
  branchId         String?
  supportGroup     SupportGroup     @default(IT_HELPDESK)
  isConfidential   Boolean          @default(false)
  issueClassification IssueClassification?
  rootCause        String?
  preventiveMeasures String?
  knowledgeBaseCreated Boolean       @default(false)
  estimatedHours   Int?
  actualHours      Float?
  resolutionNotes  String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  resolvedAt       DateTime?
  closedAt         DateTime?

  // Relations
  service       Service             @relation(fields: [serviceId], references: [id])
  createdBy     User                @relation("TicketCreator", fields: [createdById], references: [id])
  assignedTo    User?               @relation("TicketAssignee", fields: [assignedToId], references: [id])
  branch        Branch?             @relation(fields: [branchId], references: [id])
  fieldValues   TicketFieldValue[]
  comments      TicketComment[]
  attachments   TicketAttachment[]
  approvals     TicketApproval[]
  slaTracking   SLATracking[]
  auditLogs     AuditLog[]
  vendorTickets VendorTicket[]
  tasks         TicketTask[]

  @@map("tickets")
}

model TicketFieldValue {
  id      String @id @default(cuid())
  ticketId String
  fieldId String
  value   String

  // Relations
  ticket Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  field  ServiceField @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([ticketId, fieldId])
  @@map("ticket_field_values")
}

model TicketComment {
  id        String   @id @default(cuid())
  ticketId  String
  userId    String
  content   String
  isInternal Boolean @default(false)
  createdAt DateTime @default(now())

  // Relations
  ticket      Ticket                 @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User                   @relation(fields: [userId], references: [id])
  attachments CommentAttachment[]

  @@map("ticket_comments")
}

model TicketAttachment {
  id        String   @id @default(cuid())
  ticketId  String
  filename  String
  originalName String
  mimeType  String
  size      Int
  path      String
  createdAt DateTime @default(now())

  // Relations
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_attachments")
}

model CommentAttachment {
  id        String   @id @default(cuid())
  commentId String
  filename  String
  originalName String
  mimeType  String
  size      Int
  path      String
  createdAt DateTime @default(now())

  // Relations
  comment TicketComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@map("comment_attachments")
}

// 3-Tier Category Structure
model Category {
  id          String   @id @default(cuid())
  name        String
  description String?
  isActive    Boolean  @default(true)
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  subcategories Subcategory[]
  services      Service[]

  @@map("categories")
}

model Subcategory {
  id          String   @id @default(cuid())
  categoryId  String
  name        String
  description String?
  isActive    Boolean  @default(true)
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  items    Item[]
  services Service[]

  @@map("subcategories")
}

model Item {
  id            String   @id @default(cuid())
  subcategoryId String
  name          String
  description   String?
  isActive      Boolean  @default(true)
  order         Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  subcategory Subcategory @relation(fields: [subcategoryId], references: [id], onDelete: Cascade)
  services    Service[]

  @@map("items")
}

// Approval Workflow
model TicketApproval {
  id        String         @id @default(cuid())
  ticketId  String
  approverId String
  status    ApprovalStatus @default(PENDING)
  reason    String?
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  // Relations
  ticket   Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  approver User   @relation(fields: [approverId], references: [id])

  @@map("ticket_approvals")
}

// SLA Management
model SLATemplate {
  id              String   @id @default(cuid())
  serviceId       String   @unique
  responseHours   Int      @default(4)
  resolutionHours Int      @default(24)
  escalationHours Int      @default(48)
  businessHoursOnly Boolean @default(true)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  service     Service       @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  slaTracking SLATracking[]

  @@map("sla_templates")
}

model SLATracking {
  id              String     @id @default(cuid())
  ticketId        String
  slaTemplateId   String
  responseDeadline DateTime
  resolutionDeadline DateTime
  escalationDeadline DateTime
  responseTime    DateTime?
  resolutionTime  DateTime?
  isResponseBreached Boolean @default(false)
  isResolutionBreached Boolean @default(false)
  isEscalated     Boolean    @default(false)
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  ticket      Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  slaTemplate SLATemplate @relation(fields: [slaTemplateId], references: [id])

  @@map("sla_tracking")
}

// ATM Monitoring
model ATM {
  id        String    @id @default(cuid())
  code      String    @unique
  name      String
  branchId  String
  ipAddress String?
  location  String?
  latitude  Float?
  longitude Float?
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  branch           Branch            @relation(fields: [branchId], references: [id])
  monitoringLogs   ATMMonitoringLog[]
  incidents        ATMIncident[]

  @@map("atms")
}

model ATMMonitoringLog {
  id          String   @id @default(cuid())
  atmId       String
  status      ATMStatus
  responseTime Float?
  errorMessage String?
  checkedAt   DateTime @default(now())

  // Relations
  atm ATM @relation(fields: [atmId], references: [id], onDelete: Cascade)

  @@map("atm_monitoring_logs")
}

model ATMIncident {
  id          String        @id @default(cuid())
  atmId       String
  ticketId    String?
  type        IncidentType
  severity    IncidentSeverity
  description String
  status      IncidentStatus @default(OPEN)
  detectedAt  DateTime      @default(now())
  resolvedAt  DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  // Relations
  atm ATM @relation(fields: [atmId], references: [id])

  @@map("atm_incidents")
}

// Vendor Management
model Vendor {
  id          String   @id @default(cuid())
  name        String
  contactName String?
  email       String?
  phone       String?
  address     String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  vendorTickets VendorTicket[]

  @@map("vendors")
}

model VendorTicket {
  id              String       @id @default(cuid())
  ticketId        String
  vendorId        String
  vendorTicketId  String?
  status          VendorStatus @default(PENDING)
  description     String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  // Relations
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  vendor Vendor @relation(fields: [vendorId], references: [id])

  @@map("vendor_tickets")
}

// Audit & Logging
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  ticketId  String?
  action    String
  entity    String
  entityId  String
  oldValues Json?
  newValues Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  // Relations
  user   User?   @relation(fields: [userId], references: [id])
  ticket Ticket? @relation(fields: [ticketId], references: [id])

  @@map("audit_logs")
}

// Knowledge Base
model KnowledgeArticle {
  id          String   @id @default(cuid())
  title       String
  content     String
  categoryId  String?
  tags        String[]
  isPublished Boolean  @default(false)
  viewCount   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("knowledge_articles")
}

// Task Management
model TaskTemplate {
  id          String   @id @default(cuid())
  serviceId   String
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  service Service           @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  items   TaskTemplateItem[]

  @@map("task_templates")
}

model TaskTemplateItem {
  id             String   @id @default(cuid())
  taskTemplateId String
  title          String
  description    String?
  estimatedMinutes Int?   @default(30)
  order          Int      @default(0)
  isRequired     Boolean  @default(true)
  knowledgeBaseUrl String?
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  taskTemplate TaskTemplate @relation(fields: [taskTemplateId], references: [id], onDelete: Cascade)
  ticketTasks  TicketTask[]

  @@map("task_template_items")
}

model TicketTask {
  id                 String    @id @default(cuid())
  ticketId           String
  taskTemplateItemId String
  status             TaskStatus @default(PENDING)
  startedAt          DateTime?
  completedAt        DateTime?
  actualMinutes      Int?
  notes              String?
  completedById      String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  ticket           Ticket           @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  taskTemplateItem TaskTemplateItem @relation(fields: [taskTemplateItemId], references: [id])
  completedBy      User?            @relation(fields: [completedById], references: [id])

  @@unique([ticketId, taskTemplateItemId])
  @@map("ticket_tasks")
}

// Enums
enum UserRole {
  USER
  TECHNICIAN
  MANAGER
  ADMIN
  SECURITY_ANALYST
}

enum TicketCategory {
  INCIDENT
  SERVICE_REQUEST
  CHANGE_REQUEST
  EVENT_REQUEST
}

enum TicketStatus {
  OPEN
  PENDING_APPROVAL
  APPROVED
  REJECTED
  IN_PROGRESS
  PENDING_VENDOR
  RESOLVED
  CLOSED
  CANCELLED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
  EMERGENCY
}

enum SupportGroup {
  IT_HELPDESK
  DUKUNGAN_DAN_LAYANAN
  SECURITY
  NETWORK
}

enum IssueClassification {
  HUMAN_ERROR
  SYSTEM_ERROR
  HARDWARE_FAILURE
  NETWORK_ISSUE
  SECURITY_INCIDENT
  DATA_ISSUE
  PROCESS_GAP
  EXTERNAL_FACTOR
}

enum FieldType {
  TEXT
  TEXTAREA
  EMAIL
  PHONE
  NUMBER
  DATE
  DATETIME
  SELECT
  MULTISELECT
  RADIO
  CHECKBOX
  FILE
  URL
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ATMStatus {
  ONLINE
  OFFLINE
  WARNING
  ERROR
  MAINTENANCE
}

enum IncidentType {
  NETWORK_DOWN
  HARDWARE_FAILURE
  SOFTWARE_ERROR
  MAINTENANCE
  SECURITY_BREACH
}

enum IncidentSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum VendorStatus {
  PENDING
  SUBMITTED
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TaskStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}