import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { ShiftType } from '@prisma/client';

/**
 * POST /api/shifts/schedules/[scheduleId]/assignments/manual
 * Create a single manual assignment
 *
 * Required: MANAGER or ADMIN role
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { scheduleId: string } }
) {
  try {
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check role permissions
    if (!['MANAGER', 'MANAGER_IT', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions. Manager, IT Manager, or Admin role required.' },
        { status: 403 }
      );
    }

    const scheduleId = params.scheduleId;
    const body = await request.json();
    const { staffProfileId, date, shiftType } = body;

    // Validate inputs
    if (!staffProfileId || !date || !shiftType) {
      return NextResponse.json(
        { error: 'staffProfileId, date, and shiftType are required' },
        { status: 400 }
      );
    }

    // Validate shiftType
    const validShiftTypes = Object.values(ShiftType);
    if (!validShiftTypes.includes(shiftType as ShiftType)) {
      return NextResponse.json(
        { error: `Invalid shiftType. Must be one of: ${validShiftTypes.join(', ')}` },
        { status: 400 }
      );
    }

    // Check if schedule exists and is editable
    const schedule = await prisma.shiftSchedule.findUnique({
      where: { id: scheduleId },
    });

    if (!schedule) {
      return NextResponse.json({ error: 'Schedule not found' }, { status: 404 });
    }

    if (schedule.status === 'PUBLISHED' || schedule.status === 'ARCHIVED') {
      return NextResponse.json(
        { error: 'Cannot modify published or archived schedules' },
        { status: 400 }
      );
    }

    // Check if staff profile exists
    const staffProfile = await prisma.staffShiftProfile.findUnique({
      where: { id: staffProfileId },
      include: { user: true },
    });

    if (!staffProfile) {
      return NextResponse.json({ error: 'Staff profile not found' }, { status: 404 });
    }

    // Validate date is within the schedule's month
    const assignmentDate = new Date(date);
    if (
      assignmentDate.getMonth() + 1 !== schedule.month ||
      assignmentDate.getFullYear() !== schedule.year
    ) {
      return NextResponse.json(
        { error: 'Assignment date must be within the schedule month' },
        { status: 400 }
      );
    }

    // Check for existing assignment on same date and shift type
    const existingAssignment = await prisma.shiftAssignment.findFirst({
      where: {
        scheduleId,
        date: assignmentDate,
        shiftType: shiftType as ShiftType,
      },
    });

    if (existingAssignment) {
      // Update existing assignment instead
      const updatedAssignment = await prisma.shiftAssignment.update({
        where: { id: existingAssignment.id },
        data: {
          staffProfileId,
          isAutoGenerated: false,
        },
        include: {
          staffProfile: {
            include: {
              user: true,
            },
          },
        },
      });

      return NextResponse.json({
        success: true,
        data: updatedAssignment,
        message: 'Assignment updated',
      });
    }

    // Create new assignment
    const assignment = await prisma.shiftAssignment.create({
      data: {
        scheduleId,
        staffProfileId,
        date: assignmentDate,
        shiftType: shiftType as ShiftType,
        isAutoGenerated: false,
      },
      include: {
        staffProfile: {
          include: {
            user: true,
          },
        },
      },
    });

    // Auto-create OFF day H+1 after Type 1 (NIGHT_WEEKDAY) or Type 3 (NIGHT_WEEKEND)
    if (shiftType === 'NIGHT_WEEKDAY' || shiftType === 'NIGHT_WEEKEND') {
      const nextDay = new Date(assignmentDate);
      nextDay.setDate(nextDay.getDate() + 1);

      // Check if next day is still in the same month
      if (nextDay.getMonth() + 1 === schedule.month) {
        // Check if there's no existing assignment for this staff on next day
        const existingNextDay = await prisma.shiftAssignment.findFirst({
          where: {
            scheduleId,
            staffProfileId,
            date: nextDay,
          },
        });

        if (!existingNextDay) {
          await prisma.shiftAssignment.create({
            data: {
              scheduleId,
              staffProfileId,
              date: nextDay,
              shiftType: ShiftType.OFF,
              isAutoGenerated: true,
            },
          });
          console.log(`âœ“ Auto-created OFF day on ${nextDay.toISOString().split('T')[0]} after ${shiftType}`);
        }
      }
    }

    return NextResponse.json({
      success: true,
      data: assignment,
      message: 'Assignment created',
    });
  } catch (error: any) {
    console.error('Error creating manual assignment:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create assignment' },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/shifts/schedules/[scheduleId]/assignments/manual?assignmentId=xxx
 * Delete a single assignment
 *
 * Required: MANAGER or ADMIN role
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { scheduleId: string } }
) {
  try {
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check role permissions
    if (!['MANAGER', 'MANAGER_IT', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions. Manager, IT Manager, or Admin role required.' },
        { status: 403 }
      );
    }

    const scheduleId = params.scheduleId;
    const { searchParams } = new URL(request.url);
    const assignmentId = searchParams.get('assignmentId');

    if (!assignmentId) {
      return NextResponse.json(
        { error: 'assignmentId is required' },
        { status: 400 }
      );
    }

    // Check if schedule exists and is editable
    const schedule = await prisma.shiftSchedule.findUnique({
      where: { id: scheduleId },
    });

    if (!schedule) {
      return NextResponse.json({ error: 'Schedule not found' }, { status: 404 });
    }

    if (schedule.status === 'PUBLISHED' || schedule.status === 'ARCHIVED') {
      return NextResponse.json(
        { error: 'Cannot modify published or archived schedules' },
        { status: 400 }
      );
    }

    // Check if assignment exists
    const assignment = await prisma.shiftAssignment.findUnique({
      where: { id: assignmentId },
    });

    if (!assignment) {
      return NextResponse.json({ error: 'Assignment not found' }, { status: 404 });
    }

    // Verify assignment belongs to this schedule
    if (assignment.scheduleId !== scheduleId) {
      return NextResponse.json(
        { error: 'Assignment does not belong to this schedule' },
        { status: 400 }
      );
    }

    // Delete the assignment
    await prisma.shiftAssignment.delete({
      where: { id: assignmentId },
    });

    return NextResponse.json({
      success: true,
      message: 'Assignment deleted successfully',
    });
  } catch (error: any) {
    console.error('Error deleting assignment:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to delete assignment' },
      { status: 500 }
    );
  }
}
