import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { ShiftType } from '@prisma/client';

/**
 * POST /api/shifts/schedules/[scheduleId]/assignments/batch
 * Create multiple assignments in batch
 *
 * Required: MANAGER or ADMIN role
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { scheduleId: string } }
) {
  try {
    const session = await auth();

    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Check role permissions
    if (!['MANAGER', 'MANAGER_IT', 'ADMIN'].includes(session.user.role)) {
      return NextResponse.json(
        { error: 'Insufficient permissions. Manager, IT Manager, or Admin role required.' },
        { status: 403 }
      );
    }

    const scheduleId = params.scheduleId;
    const body = await request.json();
    const { assignments } = body;

    // Validate inputs
    if (!assignments || !Array.isArray(assignments) || assignments.length === 0) {
      return NextResponse.json(
        { error: 'assignments array is required and must not be empty' },
        { status: 400 }
      );
    }

    // Check if schedule exists and is editable
    const schedule = await prisma.shiftSchedule.findUnique({
      where: { id: scheduleId },
    });

    if (!schedule) {
      return NextResponse.json({ error: 'Schedule not found' }, { status: 404 });
    }

    if (schedule.status === 'PUBLISHED' || schedule.status === 'ARCHIVED') {
      return NextResponse.json(
        { error: 'Cannot modify published or archived schedules' },
        { status: 400 }
      );
    }

    const validShiftTypes = Object.values(ShiftType);
    const results = {
      created: 0,
      updated: 0,
      failed: 0,
      errors: [] as string[],
    };

    // Process each assignment
    for (const assignment of assignments) {
      try {
        const { staffProfileId, date, shiftType } = assignment;

        // Validate required fields
        if (!staffProfileId || !date || !shiftType) {
          results.failed++;
          results.errors.push(`Missing required fields for assignment`);
          continue;
        }

        // Validate shiftType
        if (!validShiftTypes.includes(shiftType as ShiftType)) {
          results.failed++;
          results.errors.push(`Invalid shiftType: ${shiftType}`);
          continue;
        }

        // Validate date is within the schedule's month
        const assignmentDate = new Date(date);
        if (
          assignmentDate.getMonth() + 1 !== schedule.month ||
          assignmentDate.getFullYear() !== schedule.year
        ) {
          results.failed++;
          results.errors.push(`Assignment date ${date} is not within schedule month`);
          continue;
        }

        // Check for existing assignment on same date and shift type
        const existingAssignment = await prisma.shiftAssignment.findFirst({
          where: {
            scheduleId,
            date: assignmentDate,
            shiftType: shiftType as ShiftType,
          },
        });

        if (existingAssignment) {
          // Update existing assignment
          await prisma.shiftAssignment.update({
            where: { id: existingAssignment.id },
            data: {
              staffProfileId,
              isAutoGenerated: false,
            },
          });
          results.updated++;
        } else {
          // Create new assignment
          await prisma.shiftAssignment.create({
            data: {
              scheduleId,
              staffProfileId,
              date: assignmentDate,
              shiftType: shiftType as ShiftType,
              isAutoGenerated: false,
            },
          });
          results.created++;

          // Auto-create OFF day after night shift
          if (shiftType === 'NIGHT') {
            const nextDay = new Date(assignmentDate);
            nextDay.setDate(nextDay.getDate() + 1);

            // Check if next day is still in the same month
            if (nextDay.getMonth() + 1 === schedule.month) {
              // Check if there's no existing assignment for this staff on next day
              const existingNextDay = await prisma.shiftAssignment.findFirst({
                where: {
                  scheduleId,
                  staffProfileId,
                  date: nextDay,
                },
              });

              if (!existingNextDay) {
                await prisma.shiftAssignment.create({
                  data: {
                    scheduleId,
                    staffProfileId,
                    date: nextDay,
                    shiftType: ShiftType.OFF,
                    isAutoGenerated: true,
                  },
                });
              }
            }
          }
        }
      } catch (error: any) {
        results.failed++;
        results.errors.push(error.message || 'Unknown error');
        console.error('Error processing assignment:', error);
      }
    }

    return NextResponse.json({
      success: true,
      data: {
        total: assignments.length,
        created: results.created,
        updated: results.updated,
        failed: results.failed,
        errors: results.errors,
      },
      message: `Processed ${assignments.length} assignments: ${results.created} created, ${results.updated} updated, ${results.failed} failed`,
    });
  } catch (error: any) {
    console.error('Error creating batch assignments:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to create batch assignments' },
      { status: 500 }
    );
  }
}
